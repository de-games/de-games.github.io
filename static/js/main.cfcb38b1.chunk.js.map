{"version":3,"sources":["components/NavbarElements.js","utils/Auth.js","utils/Service.js","utils/Web3Service.js","components/Navbar.js","pages/Home.js","pages/About.js","pages/Events.js","pages/Teams.js","pages/Blogs.js","pages/Games.js","components/Login.js","games/pacman/components/Board.tsx","games/pacman/util/assert.ts","games/pacman/components/StoreContext.ts","games/pacman/model/MazeData.ts","games/pacman/model/Coordinates.ts","games/pacman/components/Sprite.tsx","games/pacman/components/Box.tsx","games/pacman/model/collisionDetection.ts","games/pacman/model/eatEnergizer.ts","games/pacman/model/detectCollisions.ts","games/pacman/model/pacManDyingPhase.ts","games/pacman/pages/GamePage/components/PacManView.tsx","games/pacman/pages/GamePage/components/ExtraLives.tsx","games/pacman/pages/GamePage/components/Message.tsx","games/pacman/pages/GamePage/components/GameOver.tsx","games/pacman/pages/WayFindingPage/WayPoint.tsx","games/pacman/model/getDirectionFromTileToTile.ts","games/pacman/pages/WayFindingPage/WayPoints.tsx","games/pacman/pages/GamePage/components/Target.tsx","games/pacman/pages/GamePage/components/GhostsView.tsx","games/pacman/pages/GamePage/components/MazeView.tsx","games/pacman/pages/GamePage/components/PillsView.tsx","games/pacman/pages/GamePage/components/Score.tsx","games/pacman/components/Spacer.tsx","games/pacman/model/Types.ts","games/pacman/model/Vector.ts","games/pacman/model/Ways.ts","games/pacman/model/getTileDistance.ts","games/pacman/model/chooseNewTargetTile.ts","games/pacman/model/chooseNextTile.ts","games/pacman/model/updateGhostStatePhase.ts","games/pacman/model/updateGhosts.ts","games/pacman/model/movePacManBy.ts","games/pacman/model/updatePacMan.ts","games/pacman/model/onAnimationFrame.ts","games/pacman/model/updateExternalTimeStamp.ts","games/pacman/model/updateGameTimestamp.ts","games/pacman/model/updateEnergizerTimer.ts","games/pacman/model/useGameLoop.ts","games/pacman/model/useAnimationLoop.ts","games/pacman/pages/GamePage/GamePage.tsx","games/pacman/pages/GamePage/components/useKeyboardActions.ts","games/pacman/model/changeDirectionToOpposite.ts","games/pacman/model/GhostStateChart.ts","games/pacman/model/TimeoutTimer.ts","games/pacman/model/Ghost.ts","games/pacman/model/findWayPoints.ts","games/pacman/model/makeGhosts.ts","games/pacman/model/Maze.ts","games/pacman/model/PacManStateChart.ts","games/pacman/model/PacMan.ts","games/pacman/model/Game.ts","games/pacman/model/DebugState.ts","games/pacman/model/Store.ts","games/pacman/PacmanGame.tsx","pages/Logout.js","components/App.js","index.js"],"names":["Nav","styled","nav","NavLink","Link","Bars","FaBars","NavMenu","div","NavBtn","NavBtnLink","LS_KEY","getToken","localStorage","getItem","getAccessToken","token","accessToken","JSON","parse","console","error","Service","jsonOrFail","response","ok","Error","status","data","json","catch","err","getRequest","endpoint","a","auth","actualToken","Promise","resolve","reject","authHeader","Authorization","fetch","process","headers","method","then","postRequest","body","stringify","getAbi","abiName","txnPlayerGameTicker","userCreateAccessToken","publicAddress","signature","userGetNonce","getWalletBalance","getAbiFutureToken","getConsumableBalance","consumeGameTicket","x","y","Web3Service","web3","undefined","futureTokenABI","init","log","window","ethereum","alert","enable","Web3","futureABI","networks","futureToken","eth","Contract","abi","userAddress","getCoinbase","coinbase","toLowerCase","loginSignature","nonce","loginMessage","personal","sign","balanceOf","methods","call","dappTokenBalance","toString","transfer","senderAddress","recevierAddress","amount","send","from","payGameFee","gameAddress","payGameFeeNative","txnPlayerToGame","instance","getInstance","Navbar","React","useState","walletBalance","setWalletBalance","useEffect","getBalance","tokenBalance","handleFeeClick","web3Service","to","activeStyle","style","color","onClick","Home","display","justifyContent","alignItems","height","About","Events","Teams","Blogs","PlayGame","setAuth","consumableBalance","setConsumableBalance","ls","className","success","document","location","href","Login","setLoading","setAuthState","handleLoggedIn","setItem","handleLoginClick","src","alt","Board","children","classNames","assert","condition","msg","StoreContext","createContext","StoreProvider","Provider","useStore","store","useContext","useGame","game","BASIC_PILL_ID","getLayer","layerName","layer","MapData","layers","find","name","pillsLayer","waysLayer","MAZE_WIDTH_IN_TILES","width","MAZE_HEIGHT_IN_TILES","getTileMatrix","tileMatrix","Array","dataIndex","ty","tx","tileId","waysMatrix","SCALE_FACTOR","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER","SCREEN_TILE_CENTER_VECTOR","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_HEIGHT_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","Math","floor","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","scale","Sprite","spriteName","position","left","top","transform","transformOrigin","Box","rect","backgroundColor","zIndex","collide","rect1","rect2","eatEnergizer","action","score","killedGhosts","pacMan","ghosts","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","maze","pills","eatPill","ghostCollidesWithPacMan","ghost","detectCollisions","dead","pillTile","tileCoordinates","pillHitBox","pacManHitBox","screenCoordinates","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","TotalPacManDyingAnimationLength","keys","PacManDyingPhaseLength","PacManView","observer","alive","direction","gameViewOptions","debugState","pacManAnimationPhase","getPacManAnimationPhase","dyingPhase","timeSinceDeath","PacManDyingPhaseCount","getPacManDyingPhase","hitBox","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","dyingPacManAnimationPhase","step","round","timestamp","PacManSprite","DyingPacManSprite","PacManHitBox","ExtraLives","Layout","times","extraLivesLeft","n","Message","text","MessageStyled","span","GameOver","gameOver","POINTS","DirectionToAngle","DOWN","LEFT","UP","RIGHT","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","TUNNEL_X_RIGHT","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","WayPoints","wayPoints","map","wayPoint","index","getDirection","length","indexToUse","fromTile","toTile","Target","version","d","GhostsGameView","ghostViewOptions","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","ghostNumber","target","GhostView","colorCode","targetTile","animationPhase","state","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","MazeView","BasicPillView","EnergizerView","PillView","PillsView","memo","_","displayName","Score","SIZE_MAPPING","small","medium","large","mappedSize","size","VSpace","Directions","assertValidDirection","includes","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","directionToVector","distance","moveFromTile","steps","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","getTileDistance","neighbourTile","dx","abs","dy","sqrt","pow","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","isInsideBoxWalls","chooseForGhost2InChaseState","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","filter","max","newDirection","random","chooseInDeadMode","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","candidates","possibleNextTile","distanceToTarget","push","bestCandidate","minBy","neighbourTileInCurrentDirection","isWayFreeForGhostAt","updateGhostStatePhaseTime","statePhaseTimer","advance","lastFrameLength","updateGhostStatePhase","atTileCenter","isTimedOut","setDuration","getStatePhaseLength","restart","updateGhost","ghostPaused","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","deadWaitingTimeInBoxLeft","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","canPassThroughBoxDoor","getGhostMovementVector","moveGhostBy","speed","movePacManBy","updateLivingPacMan","nextDirection","movePacMan","delta","directionAsVector","updateDeadPacMan","revivePacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","gamePaused","frameCount","updateGameTimestamp","energizerTimer","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","useRef","animate","current","requestAnimationFrame","cancelAnimationFrame","useAnimationLoop","GamePage","resetGame","onKeyDown","useCallback","event","pressedKey","key","addEventListener","removeEventListener","useKeyboardActions","ScoreArea","justify","EmptyArea","BoardArea","changeDirectionToOpposite","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","actions","COLLISION_WITH_PAC_MAN","scatter","frightened","ENERGIZER_TIMED_OUT","REVIVED","TimeoutTimer","bound","duration","onTimedOut","this","running","timeSpent","timePassed","stop","start","observable","computed","KILL_GHOST_SCORE","Ghost","ref","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","stateChanges","value","matches","timeLeft","frightenedAboutToEnd","origin","destination","way","workingDirection","some","findWayPoints","isOutsideBoxSpace","resetGhosts","setTileCoordinates","resetGhost","Maze","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","handleTransition","diedAtTimestamp","resetPacMan","Game","handleEnergizerTimedOut","makeGhosts","DebugState","somePlaceholder","Store","readyGameForPlay","PacmanGame","Logout","removeItem","App","path","exact","element","Games","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.cfcb38b1.chunk.js","sourcesContent":["import { FaBars } from 'react-icons/fa';\nimport { NavLink as Link } from 'react-router-dom';\nimport styled from 'styled-components';\n\nexport const Nav = styled.nav`\nbackground: #181F2A;\nheight: 64px;\ndisplay: flex;\njustify-content: space-between;\npadding: 0.2rem calc((100vw - 1000px) / 2);\nz-index: 12;\n`;\n\nexport const NavLink = styled(Link)`\ncolor: #FFFFFF;\ndisplay: flex;\nalign-items: center;\ntext-decoration: none;\npadding: 0 1rem;\nheight: 100%;\ncursor: pointer;\n&.active {\n\tcolor: #10FFB7;\n}\n\n`;\n\nexport const Bars = styled(FaBars)`\ndisplay: none;\ncolor: #10FFB7;\n@media screen and (max-width: 768px) {\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 0;\n\tright: 0;\n\ttransform: translate(-100%, 75%);\n\tfont-size: 1.8rem;\n\tcursor: pointer;\n}\n`;\n\nexport const NavMenu = styled.div`\ndisplay: flex;\nalign-items: center;\nmargin-right: -24px;\n@media screen and (max-width: 768px) {\n\tdisplay: none;\n}\n`;\n\nexport const NavBtn = styled.nav`\ndisplay: flex;\nalign-items: center;\nmargin-right: 24px;\n@media screen and (max-width: 768px) {\n\tdisplay: none;\n}\n`;\n\nexport const NavBtnLink = styled(Link)`\nborder-radius: 4px;\nbackground: #FFFFFF;\npadding: 10px 22px;\ncolor: #000000;\noutline: none;\nborder: none;\ncursor: pointer;\ntransition: all 0.2s ease-in-out;\ntext-decoration: none;\nmargin-left: 24px;\n&:hover {\n\ttransition: all 0.2s ease-in-out;\n\tbackground: #10FFB7;\n\tcolor: #000000;\n}\n`;\n","export const LS_KEY = \"future\";\n\nexport const logout = () => {\n  localStorage.removeItem(LS_KEY);\n};\n\nexport const login = (auth) => {\n  localStorage.setItem(LS_KEY, JSON.stringify(auth));\n};\n\nexport const getToken = () => {\n  return localStorage.getItem(LS_KEY);\n};\n\nexport const getAccessToken = () => {\n  const token = localStorage.getItem(LS_KEY);\n  const accessToken = token && JSON.parse(token).accessToken;\n  if(!accessToken){\n    console.error('AccessToken not found.')\n  }\n  return accessToken;\n};\n\n","import { getAccessToken } from \"./Auth\";\n\nexport class Service {\n  static jsonOrFail = (response) => {\n    if (!response.ok) {\n      throw new Error(`HTTP status=${response.status}; data=${response.data}`);\n    }\n    return response.json().catch((err) => {\n      throw new Error(err);\n    });\n  };\n\n  static getRequest = async (endpoint, auth = true) => {\n    const actualToken = getAccessToken();\n    if (!actualToken && auth) {\n      return new Promise((resolve, reject) => {\n        reject(\"No auth-token found.\");\n      });\n    }\n    const authHeader =\n      (auth && { Authorization: `Bearer ${actualToken}` }) || {};\n    return fetch(`${process.env.REACT_APP_BACKEND_URL}/v1${endpoint}`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...authHeader,\n      },\n      method: \"GET\",\n    }).then(Service.jsonOrFail);\n  };\n\n  static postRequest = async (endpoint, data, auth = true) => {\n    const actualToken = getAccessToken();\n    if (!actualToken && auth) {\n      return new Promise((resolve, reject) => {\n        reject(\"No auth-token found.\");\n      });\n    }\n    const authHeader =\n      (auth && { Authorization: `Bearer ${actualToken}` }) || {};\n    return fetch(`${process.env.REACT_APP_BACKEND_URL}/v1${endpoint}`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...authHeader,\n      },\n      method: \"POST\",\n      body: JSON.stringify(data),\n    }).then(Service.jsonOrFail);\n  };\n\n  static getAbi = async (abiName) => {\n    const endpoint = `/abi/${abiName}`;\n    return Service.getRequest(endpoint);\n  };\n\n  static txnPlayerGameTicker = () => {\n    const endpoint = `/txn/player/game-ticket`;\n    return Service.postRequest(endpoint, {});\n  };\n\n  static userCreateAccessToken = (publicAddress, signature) => {\n    const endpoint = `/auth/accesstoken`;\n    return Service.postRequest(endpoint, { signature, publicAddress }, false);\n  };\n\n  static userGetNonce = (publicAddress) => {\n    const endpoint = `/auth/nonce/${publicAddress}`;\n    return Service.getRequest(endpoint, false);\n  };\n\n  static getWalletBalance = () => {\n    const endpoint = `/wallet`;\n    return Service.getRequest(endpoint);\n  };\n\n  static getAbiFutureToken = () => {\n    const endpoint = `/abi/futuretoken`;\n    return Service.getRequest(endpoint);\n  };\n\n  static getConsumableBalance = async () => {\n    const endpoint = `/txn/player/game-ticket`;\n    return Service.getRequest(endpoint);\n  };\n\n  static consumeGameTicket = async () => {\n    const endpoint = `/txn/player/use-gameticket`;\n    return Service.postRequest(endpoint, { x: \"1\", y: \"1\" });\n  };\n}\n","import Web3 from \"web3\";\nimport { Service } from \"./Service\";\n\nexport class Web3Service {\n  static instance = undefined;\n\n  static getInstance = async () => {\n    console.log(\"Web3Service.getInstance\");\n    if (Web3Service.instance) {\n      console.log(\"Web3Service.getInstance from cache\");\n      return Web3Service.instance;\n    }\n    Web3Service.instance = new Web3Service();\n    await Web3Service.instance.init();\n    return Web3Service.instance;\n  };\n\n  web3 = undefined;\n  futureTokenABI = undefined;\n\n  init = async () => {\n    if (this.web3) {\n      console.log(\"Web3 from cache.\");\n      return this.web3;\n    }\n\n    if (!window.ethereum) {\n      window.alert(\"Please install MetaMask first.\");\n      return;\n    }\n\n    if (!this.web3) {\n      try {\n        // Request account access if needed\n        await window.ethereum.enable();\n\n        // We don't know window.web3 version, so we use our own instance of Web3\n        // with the injected provider given by MetaMask\n        this.web3 = new Web3(window.ethereum);\n      } catch (error) {\n        this.window.alert(\"You need to allow MetaMask.\");\n        return;\n      }\n    }\n\n    this.futureTokenABI = await Service.getAbiFutureToken();\n    const futureABI = this.futureTokenABI;\n    const futureRopsten = futureABI.networks[5777];\n    const contractAddress = \"0x1AB2ff183735d817A285a39b240926d32997fcD7\";\n    this.futureToken = new this.web3.eth.Contract(\n      futureABI.abi,\n      contractAddress\n    );\n  };\n\n  userAddress = async () => {\n    const coinbase = await this.web3.eth.getCoinbase();\n    if (!coinbase) {\n      window.alert(\"Please activate MetaMask first.\");\n      return;\n    }\n    return coinbase.toLowerCase();\n  };\n\n  // Popup MetaMask confirmation modal to sign message\n  loginSignature = async (publicAddress, nonce) => {\n    const coinbase = await this.web3.eth.getCoinbase();\n    if (!coinbase) {\n      window.alert(\"Please activate MetaMask first.\");\n      return;\n    }\n    const loginMessage = `I am signing my one-time nonce: ${nonce}`;\n    try {\n      const signature = await this.web3.eth.personal.sign(\n        loginMessage,\n        publicAddress,\n        \"\" // MetaMask will ignore the password argument here\n      );\n      return signature;\n    } catch (err) {\n      console.log(err);\n      throw new Error(\"You need to sign the message to be able to log in.\");\n    }\n  };\n\n  balanceOf = async (userAddress) => {\n    const dappTokenBalance = await this.futureToken.methods\n      .balanceOf(userAddress)\n      .call();\n    return dappTokenBalance.toString();\n  };\n\n  transfer = async (senderAddress, recevierAddress, amount) => {\n    await this.futureToken.methods\n      .transfer(recevierAddress, amount)\n      .send({ from: senderAddress });\n  };\n\n  payGameFee = async (amount) => {\n    const userAddress = await this.userAddress();\n    const gameAddress = await this.futureToken.methods.gameAddress().call();\n    await this.futureToken.methods\n      .transfer(gameAddress, amount)\n      .send({ from: userAddress });\n  };\n\n  // TODO: fix txnPlayerToGame contract and re-check\n  // BETA: need testing\n  payGameFeeNative = async (userAddress, amount) => {\n    await this.futureToken.methods\n      .txnPlayerToGame(amount)\n      .send({ from: userAddress });\n  };\n}\n","import React, { useEffect } from \"react\";\nimport Web3 from \"web3\";\nimport {\n  Nav,\n  NavLink,\n  Bars,\n  NavMenu,\n  NavBtn,\n  NavBtnLink,\n} from \"./NavbarElements\";\nimport { getToken, Service, Web3Service } from \"../utils\";\n\nconst Navbar = () => {\n  const [walletBalance, setWalletBalance] = React.useState(\"0\");\n\n  useEffect(() => {\n    const getBalance = async () => {\n      Service.getWalletBalance()\n        .then((data) => data.tokenBalance.toString())\n        .then(setWalletBalance)\n        .catch(console.error);\n    };\n\n    const getConsumableBalance = async() => {\n      Service.getConsumableBalance()\n        .then((data) => data.amount)\n        .catch(console.error);\n    }\n\n    getBalance();\n    getConsumableBalance();\n    \n  }, []);\n\n  const handleFeeClick = async () => {\n    const web3Service = await Web3Service.getInstance();\n    try {\n      // await web3Service.payGameFee(toWei(\"100\"));\n      await web3Service.payGameFee(\"100\");\n      alert(\"We are processing your transaction please refresh in some time.\");\n    } catch (err) {}\n  };\n\n  const toEth = (amountWei) => {\n    const etherValue = Web3.utils.fromWei(amountWei, \"ether\");\n    return etherValue;\n  };\n\n  const toWei = (amountEth) => {\n    return Web3.utils.toWei(amountEth, \"ether\");\n  };\n\n  return (\n    <>\n      <Nav>\n        <Bars />\n\n        <NavMenu>\n          <NavLink to=\"/\" activeStyle>\n            Home\n          </NavLink>\n          <NavLink to=\"/about\" activeStyle>\n            About\n          </NavLink>\n          <NavLink to=\"/events\" activeStyle>\n            Events\n          </NavLink>\n          <NavLink to=\"/teams\" activeStyle>\n            Teams\n          </NavLink>\n          <NavLink to=\"/blogs\" activeStyle>\n            Blogs\n          </NavLink>\n          <NavLink to=\"/games\" activeStyle>\n            Games\n          </NavLink>\n        </NavMenu>\n        <NavBtn>\n          <NavBtnLink to=\"/games\">Games</NavBtnLink>\n        </NavBtn>\n        {getToken() && (\n          <h1 style={{ color: \"white\" }}>$Kho{walletBalance}</h1>\n        )}\n        {getToken() && (\n          <>\n            <NavBtn>\n              <NavBtnLink to=\"#\" onClick={handleFeeClick}>\n                Buy Ticket\n              </NavBtnLink>\n            </NavBtn>\n            <NavBtn>\n              <NavBtnLink to=\"/logout\">Logout</NavBtnLink>\n            </NavBtn>\n          </>\n        )}\n        {!getToken() && (\n          <NavBtn>\n            <NavBtnLink to=\"/login\">Login</NavBtnLink>\n          </NavBtn>\n        )}\n      </Nav>\n    </>\n  );\n};\n\nexport default Navbar;\n","import React from 'react';\n\nconst Home = () => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'Center',\n                alignItems: 'Center',\n                height: '100vh'\n            }}\n        >\n            <h1>Home page</h1>\n        </div>\n    );\n};\n\nexport default Home;\n","import React from 'react';\n\nconst About = () => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'Center',\n                alignItems: 'Center',\n                height: '100vh'\n            }}\n        >\n            <h1>About us.</h1>\n        </div>\n    );\n};\n\nexport default About;\n","import React from 'react';\n\nconst Events = () => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'Center',\n                alignItems: 'Center',\n                height: '100vh'\n            }}\n        >\n            <h1>Events</h1>\n        </div>\n    );\n};\n\nexport default Events;\n","import React from 'react';\n\nconst Teams = () => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'Center',\n                alignItems: 'Center',\n                height: '100vh'\n            }}\n        >\n            <h1 style={{ color: 'white' }}>Meet Team Future</h1>\n        </div>\n    );\n};\n\nexport default Teams;\n","import React from 'react';\n\nconst Blogs = () => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'Center',\n                alignItems: 'Center',\n                height: '100vh'\n            }}\n        >\n            <h1>Blogs</h1>\n\n        </div>\n    );\n};\n\nexport default Blogs;\n","import React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Service } from \"../utils\";\n\nconst PlayGame = () => {\n  const [auth, setAuth] = useState(undefined);\n  const [consumableBalance, setConsumableBalance] = useState(0);\n\n  const LS_KEY = \"future\";\n  useEffect(() => {\n    // Access token is stored in localstorage\n    const ls = window.localStorage.getItem(LS_KEY);\n    const auth = ls && JSON.parse(ls);\n    setAuth(auth);\n\n    Service.getConsumableBalance()\n      .then((data) => {\n        console.log(data);\n        setConsumableBalance(data.amount);\n      })\n      .catch(console.error);\n  }, []);\n\n  const handlePacmanClick = () => {\n    Service.consumeGameTicket()\n      .then((data) => {\n        console.log(data);\n        if (data.success == true) {\n          document.location.href = \"/games/pacman\";\n        } else {\n          alert(\"data.message\");\n        }\n      })\n      .catch(console.error);\n  };\n\n  return (\n    <div>\n      {auth ? (\n        <div>\n          {consumableBalance >= 100 ? (\n            <div>\n              <p>\n                Your current consumable balance is {consumableBalance}. Token\n                100 will be deducted post gameplay\n              </p>\n              <button className=\"ui button red \" onClick={handlePacmanClick}>\n                Play Placman\n              </button>\n            </div>\n          ) : (\n            <div className=\"center-div\">\n            \n                You do not have enough tokens to play the game. Please purchase\n                more tokens. Min 100 consumable token required\n            \n            </div>\n          )}\n        </div>\n      ) : (\n        <div className=\"App\">\n          <h1 style={{ color: \"white\" }}>Future</h1>\n          <h2 style={{ color: \"white\" }}>Sign In or Create an Account</h2>\n          <div className=\"center-div\">\n            <Link to=\"/login\">\n              <button className=\"ui button red \">Play using your wallet</button>\n            </Link>\n            <Link to=\"/games/pacman\">\n              <button className=\"ui button green center\">Play as guest</button>\n            </Link>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default PlayGame;\n","import React, { useEffect, useState } from \"react\";\nimport { Service, Web3Service } from \"../utils\";\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [auth, setAuthState] = useState(undefined);\n\n  useEffect(() => {\n    const init = async () => {};\n    init();\n  }, []);\n\n  const LS_KEY = \"future\";\n  const handleLoggedIn = (auth) => {\n    localStorage.setItem(LS_KEY, JSON.stringify(auth));\n    setAuthState(auth);\n    document.location.href = \"/\";\n  };\n\n  const handleLoginClick = async () => {\n    const web3Service = await Web3Service.getInstance();\n    const publicAddress = await web3Service.userAddress();\n    setLoading(true);\n    Service\n    .userGetNonce(publicAddress)\n    // Popup MetaMask confirmation modal to sign message\n    .then((data)=>web3Service.loginSignature(publicAddress, data.nonce))\n    // Send signature to backend on the /auth route\n    .then((signature)=>Service.userCreateAccessToken(publicAddress, signature))\n    // Pass accessToken back to parent component (to save it in localStorage)\n    .then(handleLoggedIn)\n    .catch((err) => {\n      console.error(err);\n      window.alert(err);\n      setLoading(false);\n    });\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"center-div\" >\n        <h1 style={{ color: 'white' }} >Sign in with your wallet</h1>\n        <h3 style={{ color: 'white' }}>\n          Sign in with one of available wallet providers or<br></br>create a new\n          wallet. What is a wallet?\n        </h3>\n\n        <button className=\"ui button blue\" onClick={handleLoginClick}>\n          <img\n            src=\"https://rarible.com/3ca93659526bbbdf7bca.svg\"\n            alt=\"Sign in with Metamask\"\n            className=\"icon\"\n          ></img>\n          <span className=\"buttonText\">Sign in with Metamask</span>\n        </button>\n        <p>\n          We do not own your private keys and cannot access your funds without\n          your confirmation.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default Login;\n","import React from 'react';\nimport './Board.css';\nimport classNames from 'classnames';\n\nexport const Board: React.FC<{ className?: string }> = ({\n  className,\n  children,\n}) => <div className={classNames('Board', className)}>{children}</div>;\n","export function assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(`Assertion error ${msg ?? ''}`);\n  }\n}\n","import { createContext, useContext } from 'react';\nimport { Game } from '../model/Game';\nimport { assert } from '../util/assert';\nimport { Store } from '../model/Store';\n\nexport const StoreContext = createContext<Store | null>(null);\n\nexport const StoreProvider = StoreContext.Provider;\n\nexport const useStore = (): Store => {\n  const store = useContext(StoreContext);\n  assert(store, 'Store not provided - use <StoreProvider>');\n  return store;\n};\n\nexport const useGame = (): Game => {\n  const store = useStore();\n  return store.game;\n};\n","import MapData from '../mapData/pacman6.json';\n\nexport type TileId = number;\n\nexport const EMPTY_TILE_ID: TileId = 0;\nexport const BASIC_PILL_ID: TileId = 3533;\nexport const ENERGIZER_ID: TileId = 3589;\n\nexport const WAY_FREE_ID: TileId = 5240;\nexport const BOX_DOOR_ID: TileId = 5241;\n\nexport type TileMatrix = TileId[][];\n\ninterface Layer {\n  data: number[];\n  width: number;\n  height: number;\n}\n\nconst getLayer = (layerName: string): Layer => {\n  const layer = MapData.layers.find(layer => layer.name === layerName);\n  if (!layer) {\n    throw new Error(`${layerName} layer not found`);\n  }\n  return layer;\n};\n\nconst pillsLayer: Layer = getLayer('Pills');\nconst waysLayer: Layer = getLayer('Ways');\n\nexport const MAZE_WIDTH_IN_TILES = pillsLayer.width;\nexport const MAZE_HEIGHT_IN_TILES = pillsLayer.height;\n\nexport const getTileMatrix = (data: TileId[]): TileMatrix => {\n  const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n  let dataIndex = 0;\n  for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n    tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n    for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n      const tileId = data[dataIndex];\n      tileMatrix[ty][tx] = tileId;\n      dataIndex++;\n    }\n  }\n  return tileMatrix;\n};\n\nexport const getPillsMatrix = (): TileMatrix => getTileMatrix(pillsLayer.data);\n\nexport const waysMatrix: TileMatrix = getTileMatrix(waysLayer.data);\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './MazeData';\nimport { assert } from '../util/assert';\nimport { Vector } from './Vector';\n\nexport type Coordinate = number;\n\nexport type TileCoordinate = Coordinate;\nexport type ScreenCoordinate = Coordinate;\n\nexport interface TileCoordinates {\n  x: TileCoordinate;\n  y: TileCoordinate;\n}\n\nexport interface ScreenCoordinates {\n  x: ScreenCoordinate;\n  y: ScreenCoordinate;\n}\n\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\n\nexport interface TileRectangle {\n  tile1: TileCoordinates;\n  tile2: TileCoordinates;\n}\n\nexport const SCALE_FACTOR = 2.5;\nexport const SPRITE_TILE_SIZE = 8;\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\n\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\n  x: SCREEN_TILE_CENTER,\n  y: SCREEN_TILE_CENTER,\n};\n\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES =\n  MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES =\n  MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\n\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\n  x: MAZE_WIDTH_IN_TILES,\n  y: MAZE_HEIGHT_IN_TILES,\n};\n\nexport const isTxValid = (tx: TileCoordinate) =>\n  tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\nexport const isTyValid = (ty: TileCoordinate) =>\n  ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\nexport const isValidTileCoordinates = (tile: TileCoordinates) =>\n  isTxValid(tile.x) && isTyValid(tile.y);\n\nexport const assertValidTx = (tx: TileCoordinate) => {\n  assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\n};\n\nexport const assertValidTy = (ty: TileCoordinate) => {\n  assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\n};\n\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\n  assertValidTx(tile.x);\n  assertValidTy(tile.y);\n};\n\nexport const screenFromTileCoordinate = (\n  tileCoordinate: TileCoordinate\n): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\n\nexport const tileFromScreenCoordinate = (\n  screenCoordinate: ScreenCoordinate\n): TileCoordinate => Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\n\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\n  x: screenFromTileCoordinate(tile.x),\n  y: screenFromTileCoordinate(tile.y),\n});\n\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\n  x: tileFromScreenCoordinate(screen.x),\n  y: tileFromScreenCoordinate(screen.y),\n});\n\nexport const getPointDifferenceAsVector = (\n  from: Coordinates,\n  to: Coordinates\n): Vector => ({\n  x: to.x - from.x,\n  y: to.y - from.y,\n});\n\nexport const addCoordinatesAndVector = (\n  coordinates: Coordinates,\n  vector: Vector\n): ScreenCoordinates => ({\n  x: coordinates.x + vector.x,\n  y: coordinates.y + vector.y,\n});\n\nexport const rectangleContainsTile = (\n  tileRectangle: TileRectangle,\n  tile: TileCoordinates\n): boolean =>\n  tile.x >= tileRectangle.tile1.x &&\n  tile.x <= tileRectangle.tile2.x &&\n  tile.y >= tileRectangle.tile1.y &&\n  tile.y <= tileRectangle.tile2.y;\n\nexport const wrapTileToBounds = (\n  tile: TileCoordinates,\n  bounds: TileCoordinates\n): TileCoordinates => {\n  const wrappedX = (tile.x + bounds.x) % bounds.x;\n  const wrappedY = (tile.y + bounds.y) % bounds.y;\n  return { x: wrappedX, y: wrappedY };\n};\n","import React, { FC, CSSProperties } from 'react';\nimport classNames from 'classnames';\nimport { SCALE_FACTOR } from '../model/Coordinates';\nimport './Sprite.css';\n\nconst scale = `scale(${SCALE_FACTOR})`;\n\nexport const Sprite: FC<{\n  name: string;\n  x: number;\n  y: number;\n  className?: string | null;\n  style?: CSSProperties;\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\n  return (\n    <div\n      className={classNames('Sprite', 'Sprite-' + spriteName, className)}\n      style={{\n        ...style,\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        transform: scale,\n        transformOrigin: 'top left',\n      }}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { Rectangle } from '../model/Rectangle';\n\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({\n  rect,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: rect.x,\n      top: rect.y,\n      width: rect.width,\n      height: rect.height,\n      backgroundColor: color,\n      zIndex: 1000,\n    }}\n  />\n);\n","import { Rectangle } from './Rectangle';\n\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\n  return (\n    rect1.x < rect2.x + rect2.width &&\n    rect1.x + rect1.width > rect2.x &&\n    rect1.y < rect2.y + rect2.height &&\n    rect1.y + rect1.height > rect2.y\n  );\n};\n","import { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const ENERGIZER_POINTS = 30;\n\nexport const eatEnergizer = action((game: Game) => {\n  game.score += ENERGIZER_POINTS;\n  game.killedGhosts = 0;\n  game.pacMan.send('ENERGIZER_EATEN');\n  for (const ghost of game.ghosts) {\n    ghost.send('ENERGIZER_EATEN');\n  }\n});\n","import { collide } from './collisionDetection';\nimport {\n  SCALE_FACTOR,\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n} from './Coordinates';\nimport { eatEnergizer } from './eatEnergizer';\nimport { Game } from './Game';\nimport { Ghost } from './Ghost';\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './MazeData';\nimport { Rectangle } from './Rectangle';\n\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\n\nexport const getPillHitBox = (\n  tile: TileCoordinates,\n  pill: TileId\n): Rectangle => {\n  const screen = screenFromTile(tile);\n  return {\n    x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\n    y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\n    width: PILL_BOX_HIT_BOX_WIDTH,\n    height: PILL_BOX_HIT_BOX_HEIGHT,\n  };\n};\n\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\n\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\n    y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\n    width: PAC_MAN_HIT_BOX_WIDTH,\n    height: PAC_MAN_HIT_BOX_HEIGHT,\n  };\n};\n\nconst GHOST_HIT_BOX_WIDTH = 10;\nconst GHOST_HIT_BOX_HEIGHT = 10;\n\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\n    y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\n    width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\n    height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR,\n  };\n};\n\nconst detectPacManEatingPill = (game: Game) => {\n  const pillTile = game.pacMan.tileCoordinates;\n  const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\n  if (pill === EMPTY_TILE_ID) {\n    return;\n  }\n\n  const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n  if (collide(pacManHitBox, pillHitBox)) {\n    eatPillLayerObject(pillTile, game);\n  }\n};\n\nexport const BASIC_PILL_POINTS = 10;\n\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\n  const tileId = game.maze.pills[tile.y][tile.x];\n  switch (tileId) {\n    case BASIC_PILL_ID:\n      eatPill(tile, game);\n      break;\n    case ENERGIZER_ID:\n      eatEnergizer(game);\n      break;\n    default:\n      console.error('Unknown pill layer tile id', tileId);\n      break;\n  }\n\n  game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\n};\n\nconst eatPill = (tile: TileCoordinates, game: Game) => {\n  game.score += BASIC_PILL_POINTS;\n};\n\nconst detectGhostCollisions = (game: Game) => {\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n\n  for (const ghost of game.ghosts) {\n    if (ghost.dead) {\n      continue;\n    }\n\n    const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\n    if (collide(pacManHitBox, ghostHitBox)) {\n      ghostCollidesWithPacMan(ghost);\n    }\n  }\n};\n\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\n  const game = ghost.game;\n  game.pacMan.send('COLLISION_WITH_GHOST');\n  ghost.send('COLLISION_WITH_PAC_MAN');\n};\n\nexport const detectCollisions = (game: Game) => {\n  if (game.pacMan.dead) {\n    return;\n  }\n\n  detectPacManEatingPill(game);\n  detectGhostCollisions(game);\n};\n","import { MilliSeconds } from './Types';\nimport { PacMan } from './PacMan';\n\nexport type PacManDyingPhase = number;\nexport const PacManDyingPhaseCount = 13;\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(\n  Array(PacManDyingPhaseCount).keys()\n);\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\nexport const TotalPacManDyingAnimationLength: MilliSeconds =\n  PacManDyingPhaseLength * PacManDyingPhaseCount;\n\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\n  let dyingPhase: number = Math.floor(\n    pacMan.timeSinceDeath / PacManDyingPhaseLength\n  );\n  if (dyingPhase >= PacManDyingPhaseCount) {\n    dyingPhase = PacManDyingPhaseCount - 1;\n  }\n  return dyingPhase as PacManDyingPhase;\n};\n","import React, { FC, CSSProperties } from 'react';\nimport { Sprite } from '../../../components/Sprite';\nimport { Direction } from '../../../model/Types';\nimport { observer } from 'mobx-react-lite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { Box } from '../../../components/Box';\nimport { PacMan } from '../../../model/PacMan';\nimport { getPacManHitBox } from '../../../model/detectCollisions';\nimport {\n  PacManDyingPhase,\n  getPacManDyingPhase,\n} from '../../../model/pacManDyingPhase';\n\nexport type PacManAnimationPhase = 0 | 1 | 2;\n\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\n\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\n\nexport const PacManView: FC = observer(() => {\n  const store = useStore();\n  const game = useGame();\n  const pacMan = game.pacMan;\n  const { dead, alive, screenCoordinates, direction } = pacMan;\n  const { gameViewOptions } = store.debugState;\n  const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\n  const dyingPhase = getPacManDyingPhase(pacMan);\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <PacManHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n        />\n      )}\n      {alive && (\n        <PacManSprite\n          direction={direction}\n          pacManAnimationPhase={pacManAnimationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n      {dead && (\n        <DyingPacManSprite\n          dyingPacManAnimationPhase={dyingPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n    </>\n  );\n});\n\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\n  const step = Math.round(pacMan.game.timestamp / 200) % 4;\n  const phase = step === 3 ? 1 : step;\n  return phase as PacManAnimationPhase;\n};\n\nexport const PacManSprite: FC<{\n  direction: Direction;\n  pacManAnimationPhase: PacManAnimationPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-pacman\"\n    name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const DyingPacManSprite: FC<{\n  dyingPacManAnimationPhase: PacManDyingPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-dying-pacman\"\n    name={`dying-pacman-phase-${dyingPacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\n  const rect = getPacManHitBox({ x, y });\n  return <Box rect={rect} color=\"green\" />;\n};\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport classNames from 'classnames';\nimport styled from 'styled-components/macro';\nimport { PacManSprite } from './PacManView';\nimport { times } from 'lodash';\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\n\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\n  const game = useGame();\n  return (\n    <Layout className={classNames('ExtraLives', className)}>\n      <span>\n        {times(game.pacMan.extraLivesLeft, n => (\n          <PacManSprite\n            key={n}\n            direction=\"LEFT\"\n            pacManAnimationPhase={1}\n            x={n * 20 * SCALE_FACTOR}\n            y={0}\n          />\n        ))}\n      </span>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  display: inline-flex;\n  position: relative;\n  width: calc(1 * 40px * var(--SCALE_FACTOR));\n  height: calc(16px * var(--SCALE_FACTOR));\n`;\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\n\nexport const Message = observer<{ className?: string; text: string }>(\n  ({ className, text }) => {\n    return <MessageStyled className={className}>{text}</MessageStyled>;\n  }\n);\n\nconst MessageStyled = styled.span`\n  font-family: Joystix;\n  font-size: 24px;\n  color: yellow;\n  position: absolute;\n  left: 170px;\n  top: 332px;\n  width: 220px;\n  text-align: center;\n`;\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport './GameOver.css';\nimport { useGame } from '../../../components/StoreContext';\nimport { Message } from './Message';\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\n\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\n\nexport const GameOver: FC<{ className?: string }> = observer(\n  ({ className }) => {\n    const game = useGame();\n    const { pacMan } = game;\n    const gameOverMessageVisible =\n      game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\n\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\n  }\n);\n","import React from 'react';\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Direction } from '../../model/Types';\n\nconst x1 = 30;\nconst y1 = 30;\nconst x2 = 70;\nconst y2 = 70;\nconst x3 = 50;\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\n\nconst DirectionToAngle = {\n  DOWN: 0,\n  LEFT: 90,\n  UP: 180,\n  RIGHT: 270,\n};\n\nexport const WayPoint: React.FC<{\n  screenCoordinates: ScreenCoordinates;\n  color: string;\n  direction: Direction;\n}> = ({ screenCoordinates, color, direction }) => {\n  const angle = DirectionToAngle[direction];\n  return (\n    <SvgStyled\n      viewBox=\"0 0 100 100\"\n      height=\"6\"\n      width=\"6\"\n      style={{\n        left: `${screenCoordinates.x + 1}px`,\n        top: `${screenCoordinates.y}px`,\n      }}\n    >\n      <g transform={`rotate(${angle} 50 50)`}>\n        <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\n      </g>\n    </SvgStyled>\n  );\n};\n\nconst SvgStyled = styled.svg`\n  position: absolute;\n  display: block;\n  width: ${SCREEN_TILE_SIZE}px;\n  height: ${SCREEN_TILE_SIZE}px;\n  pointer-events: none;\n`;\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\nimport { isEqual } from 'lodash';\nimport { assert } from '../util/assert';\nimport { Direction } from './Types';\nimport { MAZE_WIDTH_IN_TILES } from './MazeData';\n\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\n\nexport const getDirectionFromTileToTile = (\n  tileFrom: TileCoordinates,\n  tileTo: TileCoordinates\n): Direction => {\n  assert(tileFrom, 'tileFrom');\n  assert(tileTo, 'tileTo');\n\n  if (isEqual(tileFrom, tileTo)) {\n    throw new Error('Same tile');\n  }\n\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\n    return 'RIGHT';\n  }\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\n    return 'LEFT';\n  }\n  if (tileFrom.x < tileTo.x) {\n    return 'RIGHT';\n  }\n  if (tileFrom.x > tileTo.x) {\n    return 'LEFT';\n  }\n  if (tileFrom.y < tileTo.y) {\n    return 'DOWN';\n  }\n  if (tileFrom.y > tileTo.y) {\n    return 'UP';\n  }\n  throw new Error('Same tiles');\n};\n","/* eslint-disable react/no-unescaped-entities */\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\nimport { WayPoint } from './WayPoint';\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\nimport { Direction } from '../../model/Types';\nimport { assert } from '../../util/assert';\n\nexport const WayPoints = observer<{\n  wayPoints: TileCoordinates[];\n  color: string;\n}>(({ wayPoints, color }) => (\n  <>\n    {wayPoints.map((wayPoint, index) => {\n      const screenCoordinates = screenFromTile(wayPoint);\n      const direction = getDirection(wayPoints, index);\n      return (\n        <WayPoint\n          key={index}\n          screenCoordinates={screenCoordinates}\n          color={color}\n          direction={direction}\n        />\n      );\n    })}\n  </>\n));\n\nconst getDirection = (\n  wayPoints: TileCoordinates[],\n  index: number\n): Direction => {\n  if (wayPoints.length <= 1) {\n    return 'DOWN';\n  }\n  const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\n  const fromTile = wayPoints[indexToUse];\n  const toTile = wayPoints[indexToUse + 1];\n  assert(toTile, `${indexToUse} ${wayPoints.length}`);\n  const direction = getDirectionFromTileToTile(fromTile, toTile);\n  return direction;\n};\n","import React, { FC } from 'react';\nimport {\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  screenFromTileCoordinate,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\n\nconst SIZE = SCREEN_TILE_SIZE * 2;\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\n\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({\n  tile,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: screenFromTileCoordinate(tile.x) + OFFSET,\n      top: screenFromTileCoordinate(tile.y) + OFFSET,\n      width: SIZE,\n      height: SIZE,\n    }}\n  >\n    <svg version=\"1.1\" viewBox=\"0 0 22 22\">\n      <path\n        style={{ fill: color }}\n        transform={`rotate(45 11 11) translate(-550.29-608.65)`}\n        d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\n      />\n    </svg>\n  </div>\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { getGhostHitBox } from '../../../model/detectCollisions';\nimport {\n  Ghost,\n  GhostAnimationPhase,\n  FrightenedGhostTime,\n} from '../../../model/Ghost';\nimport { Direction } from '../../../model/Types';\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { Target } from './Target';\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\nimport { GameViewOptions } from '../../../model/GameViewOptions';\n\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\n\nexport const GhostsGameView = observer(() => {\n  const store = useStore();\n  const { ghostViewOptions, gameViewOptions } = store.debugState;\n\n  return (\n    <GhostsView\n      ghostViewOptions={ghostViewOptions}\n      gameViewOptions={gameViewOptions}\n    />\n  );\n});\n\nexport const GhostsView: FC<{\n  ghostViewOptions?: GhostViewOptions;\n  gameViewOptions?: GameViewOptions;\n}> = observer(\n  ({\n    ghostViewOptions = DefaultGhostViewOptions,\n    gameViewOptions = DefaultGameViewOptions,\n  }) => {\n    const store = useGame();\n\n    return (\n      <>\n        {store.ghosts.map(ghost => (\n          <GhostCompositeView\n            key={ghost.ghostNumber}\n            ghost={ghost}\n            ghostViewOptions={ghostViewOptions}\n            gameViewOptions={gameViewOptions}\n          />\n        ))}\n      </>\n    );\n  }\n);\n\nconst DefaultGhostViewOptions: GhostViewOptions = {\n  target: false,\n  wayPoints: false,\n};\n\nconst DefaultGameViewOptions: GameViewOptions = {\n  hitBox: false,\n};\n\nexport const GhostCompositeView: FC<{\n  ghost: Ghost;\n  ghostViewOptions: GhostViewOptions;\n  gameViewOptions: GameViewOptions;\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\n  const { screenCoordinates } = ghost;\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <GhostHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n          color=\"green\"\n        />\n      )}\n      <GhostView ghost={ghost} />\n      {ghostViewOptions.wayPoints && (\n        <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />\n      )}\n      {ghostViewOptions.target && (\n        <Target tile={ghost.targetTile} color={ghost.colorCode} />\n      )}\n    </>\n  );\n});\n\nexport const GhostView: FC<{\n  ghost: Ghost;\n}> = observer(({ ghost }) => {\n  const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\n  // TODO\n  switch (ghost.state) {\n    case 'frightened':\n      return (\n        <FrightenedGhostSprite\n          frightenedGhostTime={ghost.frightenedGhostTime}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    case 'dead':\n      return (\n        <DeadGhostSprite\n          direction={direction}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    default:\n      return (\n        <GhostSprite\n          direction={direction}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n          ghostNumber={ghostNumber}\n        />\n      );\n  }\n});\n\ntype GhostSpriteProps = {\n  direction: Direction;\n  ghostAnimationPhase: GhostAnimationPhase;\n  x: number;\n  y: number;\n  ghostNumber: number;\n  style?: { [key: string]: any };\n};\n\nexport const GhostSprite: FC<GhostSpriteProps> = ({\n  direction,\n  ghostAnimationPhase: phase,\n  x,\n  y,\n  ghostNumber,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype DeadGhostSpriteProps = {\n  direction: Direction;\n  x: number;\n  y: number;\n  style?: { [key: string]: any };\n};\n\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({\n  direction,\n  x,\n  y,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`dead-ghost-direction-${direction}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype FrightenedGhostSpriteProps = {\n  x: number;\n  y: number;\n  ghostAnimationPhase: GhostAnimationPhase;\n  frightenedGhostTime: FrightenedGhostTime;\n  style?: { [key: string]: any };\n};\n\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({\n  x,\n  y,\n  ghostAnimationPhase,\n  frightenedGhostTime,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({\n  x,\n  y,\n  color,\n}) => {\n  const rect = getGhostHitBox({ x, y });\n  return <Box rect={rect} color={color} />;\n};\n\n","import React, { FC } from 'react';\nimport { Sprite } from '../../../components/Sprite';\n\nexport const MazeView: FC = () => (\n  <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC, memo } from 'react';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport {\n  addCoordinatesAndVector,\n  ScreenCoordinates,\n  screenFromTile,\n  SCREEN_TILE_CENTER_VECTOR,\n  TileCoordinates,\n} from '../../../model/Coordinates';\nimport { getPillHitBox } from '../../../model/detectCollisions';\nimport {\n  BASIC_PILL_ID,\n  ENERGIZER_ID,\n  MAZE_HEIGHT_IN_TILES,\n  MAZE_WIDTH_IN_TILES,\n  EMPTY_TILE_ID,\n} from '../../../model/MazeData';\nimport { useGame } from '../../../components/StoreContext';\n\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\n);\n\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\n);\n\nexport const BasicPillHitBox: FC = () => {\n  const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\n  return <Box rect={rect} color=\"blue\" />;\n};\n\nconst PillView = observer<{ tile: TileCoordinates }>(\n  ({ tile }: { tile: TileCoordinates }) => {\n    const game = useGame();\n    const { x, y } = tile;\n    const tileId = game.maze.pills[y][x];\n    if (tileId === BASIC_PILL_ID) {\n      return (\n        <BasicPillView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    if (tileId === ENERGIZER_ID) {\n      return (\n        <EnergizerView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    return null;\n  }\n);\n\n// Performance tricks used here:\n// Make each PillView an observer, so that we don't have to rerender PillsView.\n// Make PillsView a React.memo to prevent any rerenders.\n// Also: Create PillView only for those coordinates where there is a pill on first render.\nexport const PillsView: FC = memo(() => {\n  const game = useGame();\n\n  return (\n    <>\n      {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\n        Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\n          const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\n          return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\n        })\n      )}\n    </>\n  );\n});\n\nPillsView.displayName = 'displayName';\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport './Score.css';\nimport classNames from 'classnames';\n\nexport const Score = observer<{ className?: string }>(({ className }) => {\n  const store = useGame();\n  return (\n    <div className={classNames('Score', className)}>\n      <span>Score</span>\n      <span>{store.score}</span>\n    </div>\n  );\n});\n","import styled from 'styled-components/macro';\nconst DEFAULT_SIZE = '8px';\n\nconst SIZE_MAPPING: { [key: string]: string } = {\n  small: '8px',\n  medium: '16px',\n  large: '24px',\n};\n\ntype Size = 'small' | 'middle' | 'large' | string;\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\n\nexport const HSpace = styled.div<{ size?: Size }>`\n  width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n\nexport const VSpace = styled.div<{ size?: Size }>`\n  height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n","import { assert } from '../util/assert';\n\nexport type PixelsPerFrame = number;\n\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\n\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\n\nexport type MilliSeconds = number;\n\nexport const assertValidDirection = (direction: Direction) => {\n  assert(Directions.includes(direction), `Bad direction ${direction}`);\n};\n","export interface Vector {\n  x: number;\n  y: number;\n}\n\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector =>\n  multiplyVector(-1, vector);\n\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\n  x: factor * vector.x,\n  y: factor * vector.y,\n});\n\nexport const divideVector = (vector: Vector, divisor: number): Vector =>\n  multiplyVector(1 / divisor, vector);\n","import { Direction, assertValidDirection } from './Types';\nimport {\n  assertValidTileCoordinates,\n  ScreenCoordinates,\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  rectangleContainsTile,\n  TileRectangle,\n  wrapTileToBounds,\n  MAZE_DIMENSIONS_IN_TILES,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { waysMatrix, WAY_FREE_ID, BOX_DOOR_ID } from './MazeData';\nimport { Vector, multiplyVector } from './Vector';\n\nconst BOX_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 10, y: 12 },\n  tile2: { x: 17, y: 16 },\n};\n\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 12, y: 14 },\n  tile2: { x: 15, y: 14 },\n};\n\nexport const isWayFreeAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\n};\n\nexport const isBoxDoorAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\n};\n\nexport const isTileInBox = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_TILE_COORDINATES, tile);\n\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\n\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\n  return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\n};\n\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n\nexport const directionToVector = (direction: Direction, distance = 1): Vector =>\n  multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\n\nexport const moveFromTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  steps = 1\n) => {\n  const step = DIRECTION_TO_VECTOR[direction];\n  const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\n  return newTile;\n};\n\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\n  RIGHT: 'LEFT',\n  LEFT: 'RIGHT',\n  UP: 'DOWN',\n  DOWN: 'UP',\n};\n\nexport const isOppositeDirection = (\n  direction1: Direction,\n  direction2: Direction\n) => {\n  return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\n};\n\nexport const isWayFreeInDirection = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): boolean => {\n  const nextTile = getNextTile(tile, direction, stepSize);\n  return isWayFreeAt(nextTile);\n};\n\nexport const getNextTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): TileCoordinates => {\n  assertValidDirection(direction);\n  const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\n  const scaledVector = multiplyVector(stepSize, vector);\n  const movedTile = addCoordinatesAndVector(tile, scaledVector);\n  const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\n  return nextTile;\n};\n\nconst DIRECTION_TO_TILE_VECTOR = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n","import { TileCoordinates } from './Coordinates';\n\nexport const getTileDistance = (\n  neighbourTile: TileCoordinates,\n  targetTile: TileCoordinates\n) => {\n  const dx = Math.abs(neighbourTile.x - targetTile.x);\n  const dy = Math.abs(neighbourTile.y - targetTile.y);\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import {\n  TileCoordinates,\n  getPointDifferenceAsVector,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { Ghost } from './Ghost';\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { Directions, Direction } from './Types';\nimport { rotateVectorBy180Degrees } from './Vector';\nimport { assert } from '../util/assert';\n\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\n  x: 13,\n  y: 11,\n};\n\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\n  x: 14,\n  y: 14,\n};\n\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\n\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\n  switch (ghost.state) {\n    case 'scatter':\n      return chooseInScatterMode(ghost);\n    case 'chase':\n      return choseInChaseMode(ghost);\n    case 'frightened':\n      return chooseInFrightenedMode(ghost);\n    case 'dead':\n      return chooseInDeadMode(ghost);\n    default:\n      throw new Error(`Bad state ${ghost.state}`);\n  }\n};\n\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return SCATTER_TILE_FOR_GHOST_0;\n    case 1:\n      return { x: 1, y: 1 };\n    case 2:\n      return { x: 26, y: 29 };\n    case 3:\n      return { x: 1, y: 29 };\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  return pacMan.tileCoordinates;\n};\n\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const fourTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    4\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(fourTilesAhead, 'LEFT', 4)\n    : fourTilesAhead;\n};\n\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\n  const intermediateTile = chooseGhost2IntermediateTile(ghost);\n  const blinky = ghost.game.ghosts[0];\n  const vectorToBlinky = getPointDifferenceAsVector(\n    intermediateTile,\n    blinky.tileCoordinates\n  );\n  const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\n  const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\n\n  return newTile;\n};\n\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const twoTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    2\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(twoTilesAhead, 'LEFT', 2)\n    : twoTilesAhead;\n};\n\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const distance = getTileDistance(\n    ghost.tileCoordinates,\n    pacMan.tileCoordinates\n  );\n\n  return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\n};\n\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return chooseForGhost0InChaseState(ghost);\n    case 1:\n      return chooseForGhost1InChaseState(ghost);\n    case 2:\n      return chooseForGhost2InChaseState(ghost);\n    case 3:\n      return chooseForGhost3InChaseState(ghost);\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst getRandomInt = (max: number) =>\n  Math.floor(Math.random() * Math.floor(max));\n\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\n  // Choose a random neighbour tile that is not backward and not into a wall.\n\n  return chooseSomeRandomMovement(ghost);\n};\n\n/**\n * Choose a random neighbour tile that is not backward and not into a wall.\n */\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\n  const candidateDirections: Direction[] = Directions.filter(\n    direction =>\n      direction !== ghost.direction &&\n      isWayFreeInDirection(ghost.tileCoordinates, direction)\n  );\n  assert(candidateDirections.length > 0);\n  const newDirection =\n    candidateDirections[getRandomInt(candidateDirections.length)];\n  assert(newDirection);\n  const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\n\n  return randomNeighourTile;\n};\n\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\n  // if (ghost.deadWaitingTimeInBoxLeft < 0) {\n  //   return chooseSomeRandomMovement(ghost);\n  // }\n  return TILE_FOR_RETURNING_TO_BOX;\n};\n","import { minBy } from 'lodash';\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\nimport { Direction, Directions } from './Types';\nimport {\n  getNextTile,\n  isOppositeDirection,\n  isWayFreeAt,\n  isBoxDoorAt,\n} from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { toJS } from 'mobx';\nimport { assert } from '../util/assert';\n\ninterface CandidateTile {\n  tile: TileCoordinates;\n  distanceToTarget: number;\n}\n\nexport const chooseNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates => {\n  assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\n  const bestNextTile = chooseBestNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  if (bestNextTile) {\n    assert(isValidTileCoordinates(bestNextTile));\n    return bestNextTile;\n  }\n\n  const anyNextTile = chooseAnyNextTile({\n    currentTile,\n    currentDirection,\n    boxDoorIsOpen,\n  });\n  if (anyNextTile) {\n    assert(isValidTileCoordinates(anyNextTile));\n    return anyNextTile;\n  }\n\n  console.error('currentTile', currentTile);\n  console.error('currentDirection', currentDirection);\n  console.error('boxDoorIsOpen', boxDoorIsOpen);\n  console.error('targetTile', toJS(targetTile));\n\n  throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\n};\n\nconst chooseBestNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  const candidates = [] as CandidateTile[];\n  for (const direction of Directions) {\n    // Prevent the ghost from going backwards\n    if (isOppositeDirection(direction, currentDirection)) {\n      continue;\n    }\n    const neighbourTile = getNextTile(currentTile, direction);\n\n    if (!possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      continue;\n    }\n\n    const distanceToTarget = getTileDistance(neighbourTile, targetTile);\n    candidates.push({ tile: neighbourTile, distanceToTarget });\n  }\n\n  const bestCandidate = minBy(candidates, 'distanceToTarget');\n  if (bestCandidate) {\n    return bestCandidate.tile;\n  } else {\n    return null;\n  }\n};\n\nconst chooseAnyNextTile = ({\n  currentTile,\n  currentDirection,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  // Prioritize the current direction\n  const neighbourTileInCurrentDirection = getNextTile(\n    currentTile,\n    currentDirection\n  );\n\n  if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen)) {\n    return neighbourTileInCurrentDirection;\n  }\n\n  // Choose any possible next tile\n  for (const direction of Directions) {\n    const neighbourTile = getNextTile(currentTile, direction);\n    if (possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      return neighbourTile;\n    }\n  }\n\n  return null;\n};\n\nconst possibleNextTile = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean => {\n  return (\n    isValidTileCoordinates(tileCoordinates) &&\n    isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen)\n  );\n};\n\nconst isWayFreeForGhostAt = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean =>\n  isWayFreeAt(tileCoordinates) ||\n  (boxDoorIsOpen && isBoxDoorAt(tileCoordinates));\n","import { action } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { MilliSeconds } from './Types';\nimport { StateValue } from 'xstate';\n\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\n\nexport const updateGhostStatePhaseTime = action(\n  'updateGhostStatePhaseTime',\n  (ghost: Ghost) => {\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\n  }\n);\n\nexport const updateGhostStatePhase = action(\n  'updateGhostStatePhase',\n  (ghost: Ghost) => {\n    if (!ghost.atTileCenter) {\n      return;\n    }\n\n    if (ghost.statePhaseTimer.isTimedOut) {\n      ghost.send('PHASE_END');\n      ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\n      ghost.statePhaseTimer.restart();\n    }\n  }\n);\n\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\n  switch (state) {\n    case 'chase':\n      return CHASE_PHASE_LENGTH;\n    case 'scatter':\n      return SCATTER_PHASE_LENGTH;\n    default:\n      // Never ends\n      return 9999999999;\n  }\n};\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\nimport { chooseNextTile } from './chooseNextTile';\nimport {\n  TileCoordinates,\n  MAZE_WIDTH_IN_SCREEN_COORDINATES,\n  MAZE_HEIGHT_IN_SCREEN_COORDINATES,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\nimport { Ghost } from './Ghost';\nimport { Direction } from './Types';\nimport { directionToVector } from './Ways';\nimport {\n  updateGhostStatePhaseTime,\n  updateGhostStatePhase,\n} from './updateGhostStatePhase';\nimport { Vector } from './Vector';\nimport { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const updateGhosts = (game: Game) => {\n  for (const ghost of game.ghosts) {\n    updateGhost({ ghost });\n  }\n};\n\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\n  if (ghost.ghostPaused) {\n    return;\n  }\n\n  updateGhostStatePhaseTime(ghost);\n  updateDeadWaitingTimeInBoxLeft(ghost);\n\n  updateGhostStatePhase(ghost);\n\n  routeAndMoveGhost(ghost);\n};\n\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\n  if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\n    ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\n  }\n};\n\nexport const routeAndMoveGhost = (ghost: Ghost) => {\n  if (ghost.game.pacMan.dead) {\n    return;\n  }\n\n  if (ghost.atTileCenter) {\n    reRouteGhost(ghost);\n  }\n\n  moveGhost(ghost);\n};\n\nconst reRouteGhost = (ghost: Ghost) => {\n  ghost.targetTile = chooseNewTargetTile(ghost);\n  updateDirection(ghost);\n  updateSpeed(ghost);\n};\n\nconst updateDirection = (ghost: Ghost) => {\n  const newDirection = getNewDirection(ghost);\n  ghost.direction = newDirection;\n};\n\nconst updateSpeed = (ghost: Ghost) => {\n  const newSpeedFactor = getNewSpeedFactor(ghost);\n  ghost.speedFactor = newSpeedFactor;\n};\n\nexport const getNewDirection = (ghost: Ghost): Direction => {\n  const currentTile = ghost.tileCoordinates;\n  const currentDirection = ghost.direction;\n  const targetTile = ghost.targetTile;\n  const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\n\n  const nextTile: TileCoordinates = chooseNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  return getDirectionFromTileToTile(currentTile, nextTile);\n};\n\nconst moveGhost = (ghost: Ghost) => {\n  const vector: Vector = getGhostMovementVector(ghost);\n  moveGhostBy(ghost, vector);\n};\n\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\n  ghost.screenCoordinates.x =\n    (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  ghost.screenCoordinates.y =\n    (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) %\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES;\n\n  assertValidTileCoordinates(ghost.tileCoordinates);\n});\n\nconst isInTunnel = (tile: TileCoordinates) =>\n  tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\n\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\n  const speed = ghost.game.speed * ghost.speedFactor;\n  const velocity = directionToVector(ghost.direction, speed);\n  return velocity;\n};\n\nexport const SPEED_FACTOR_HIGH = 2;\nexport const SPEED_FACTOR_NORMAL = 1;\nexport const SPEED_FACTOR_SLOW = 0.5;\n\nconst getNewSpeedFactor = (ghost: Ghost): number => {\n  if (ghost.dead) {\n    return SPEED_FACTOR_HIGH;\n  }\n  if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\n    return SPEED_FACTOR_SLOW;\n  }\n  return SPEED_FACTOR_NORMAL;\n};\n","import { action } from 'mobx';\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { Vector } from './Vector';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\n  pacMan.screenCoordinates.x =\n    (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  pacMan.screenCoordinates.y += vector.y;\n});\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\nimport { Game } from './Game';\nimport { movePacManBy } from './movePacManBy';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport {\n  directionToVector as directionAsVector,\n  isTileCenter,\n  isWayFreeInDirection,\n} from './Ways';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const updatePacMan = (game: Game): void => {\n  const pacMan = game.pacMan;\n  if (pacMan.alive) {\n    updateLivingPacMan(pacMan);\n  } else {\n    updateDeadPacMan(pacMan);\n  }\n};\n\nconst updateLivingPacMan = (pacMan: PacMan) => {\n  if (isTileCenter(pacMan.screenCoordinates)) {\n    const tile = tileFromScreen(pacMan.screenCoordinates);\n\n    // Change direction if necessary\n    if (\n      pacMan.direction !== pacMan.nextDirection &&\n      isWayFreeInDirection(tile, pacMan.nextDirection)\n    ) {\n      pacMan.direction = pacMan.nextDirection;\n    }\n\n    // Move\n    if (isWayFreeInDirection(tile, pacMan.direction)) {\n      movePacMan(pacMan);\n    }\n  } else {\n    movePacMan(pacMan);\n  }\n};\n\nconst movePacMan = (pacMan: PacMan): void => {\n  const speed = pacMan.game.speed;\n  const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\n  movePacManBy(pacMan, delta);\n};\n\nconst updateDeadPacMan = (pacMan: PacMan) => {\n  if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\n    revivePacMan(pacMan);\n  }\n  return;\n};\n\nconst revivePacMan = (pacMan: PacMan) => {\n  if (pacMan.extraLivesLeft > 0) {\n    pacMan.extraLivesLeft -= 1;\n    pacMan.game.revivePacMan();\n  }\n};\n","import { action } from 'mobx';\nimport { detectCollisions } from './detectCollisions';\nimport { Game } from './Game';\nimport { updateGhosts } from './updateGhosts';\nimport { updatePacMan } from './updatePacMan';\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\nimport { updateGameTimestamp } from './updateGameTimestamp';\n\nexport const onAnimationFrame = action(\n  'onAnimationFrame',\n  ({ game, timestamp }: { game: Game; timestamp: number }) => {\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\n\n    if (game.gamePaused) {\n      return;\n    }\n\n    updateGameTimestamp(game);\n    updateEnergizerTimer(game);\n    updatePacMan(game);\n    updateGhosts(game);\n    detectCollisions(game);\n  }\n);\n","import { Game } from './Game';\nimport { MilliSeconds } from './Types';\n\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\n\nexport const updateExternalTimestamp = ({\n  game,\n  externalTimeStamp,\n}: {\n  game: Game;\n  externalTimeStamp: number;\n}) => {\n  if (game.externalTimeStamp === null) {\n    // The very first frame\n    // We cannot measure its duration. Therefore we have to make an assumption.\n    game.lastFrameLength = TYPICAL_FRAME_LENGTH;\n  } else {\n    // A later frame.\n    // We can calculate its duration.\n    game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\n  }\n  game.externalTimeStamp = externalTimeStamp;\n};\n","import { Game } from './Game';\n\nexport const updateGameTimestamp = (game: Game) => {\n  game.timestamp += game.lastFrameLength;\n  game.frameCount++;\n};\n","import { Game } from './Game';\n\nexport const updateEnergizerTimer = (game: Game) => {\n  game.energizerTimer.advance(game.lastFrameLength);\n};\n","import { useStore } from '../components/StoreContext';\nimport { onAnimationFrame } from './onAnimationFrame';\nimport { useAnimationLoop } from './useAnimationLoop';\n\nexport const useGameLoop = () => {\n  const store = useStore();\n\n  const animationStep = (timestamp: number) => {\n    const { game } = store;\n    onAnimationFrame({ game, timestamp });\n  };\n\n  useAnimationLoop(animationStep);\n};\n","import { useEffect, useRef } from 'react';\nimport { MilliSeconds } from './Types';\n\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\n\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\n  const requestRef = useRef(-1);\n\n  const animate = (timestamp: number) => {\n    animationStep(timestamp);\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n};\n","import { Row } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React, { useEffect } from 'react';\nimport styled from 'styled-components/macro';\nimport { Board } from '../../components/Board';\nimport { ExtraLives } from './components/ExtraLives';\nimport { GameOver } from './components/GameOver';\nimport { GhostsGameView } from './components/GhostsView';\nimport { MazeView } from './components/MazeView';\nimport { PacManView } from './components/PacManView';\nimport { PillsView } from './components/PillsView';\nimport { Score } from './components/Score';\nimport { useStore } from '../../components/StoreContext';\nimport { useKeyboardActions } from './components/useKeyboardActions';\nimport { VSpace } from '../../components/Spacer';\nimport { useGameLoop } from '../../model/useGameLoop';\n\nexport const GamePage: React.FC = observer(() => {\n  const store = useStore();\n  useEffect(() => {\n    store.resetGame();\n    return () => {\n      store.game.gamePaused = true;\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n\n  useGameLoop();\n  useKeyboardActions();\n\n  return (\n    <Layout data-teclastid=\"GamePage\">\n      <ScoreArea>\n        <Row justify=\"center\">\n          <Score />\n        </Row>\n        <VSpace size=\"small\" />\n      </ScoreArea>\n\n      <EmptyArea />\n\n      <BoardArea >\n        <Board >\n          <MazeView />\n          <PillsView />\n          <PacManView />\n          <GhostsGameView />\n          <GameOver />\n        </Board>\n        <VSpace size=\"large\" />\n        <Row justify=\"center\">\n          <ExtraLives />\n        </Row>\n      </BoardArea>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  margin-left: 16px;\n  margin-right: 16px;\n\n  display: grid;\n\n  @media (min-width: 1280px) {\n    grid-template-columns: 1fr 1fr;\n    justify-items: center;\n  }\n  @media (max-width: 1280px) {\n    grid-template-columns: 1fr;\n    justify-items: center;\n  }\n`;\n\nconst ScoreArea = styled.div``;\n\nconst EmptyArea = styled.div``;\n\nconst BoardArea = styled.div``;\n","import { useCallback, useEffect } from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\n/* eslint-disable  react-hooks/exhaustive-deps */\nexport const useKeyboardActions = (): void => {\n  const store = useStore();\n\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\n    const { game } = store;\n    const pressedKey = event.key;\n    const pacMan = game.pacMan;\n    switch (pressedKey) {\n      case 'ArrowLeft':\n        pacMan.nextDirection = 'LEFT';\n        break;\n      case 'ArrowRight':\n        pacMan.nextDirection = 'RIGHT';\n        break;\n      case 'ArrowUp':\n        pacMan.nextDirection = 'UP';\n        break;\n      case 'ArrowDown':\n        pacMan.nextDirection = 'DOWN';\n        break;\n      case ' ':\n        game.gamePaused = !game.gamePaused;\n        break;\n      default:\n        break;\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, []);\n};\n","import { Ghost } from './Ghost';\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\n\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\n  ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_GHOST_STATE = 'scatter';\n\ninterface GhostEventHandler {\n  onScatterToChase(): void;\n  onChaseToScatter(): void;\n  onDead(): void;\n}\n\ntype GhostContext = {};\n\ninterface GhostStateSchema {\n  states: {\n    chase: {};\n    scatter: {};\n    frightened: {};\n    dead: {};\n  };\n}\n\nexport type GhostEventType =\n  | 'RESET'\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'PHASE_END'\n  | 'COLLISION_WITH_PAC_MAN'\n  | 'REVIVED';\n\ntype GhostEvent = { type: GhostEventType };\n\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\n\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\n  id: 'ghost',\n  initial: INITIAL_GHOST_STATE,\n  on: {\n    RESET: INITIAL_GHOST_STATE,\n  },\n  states: {\n    chase: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'scatter',\n          actions: 'onChaseToScatter',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    scatter: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'chase',\n          actions: 'onScatterToChase',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    frightened: {\n      on: {\n        ENERGIZER_TIMED_OUT: 'chase',\n        COLLISION_WITH_PAC_MAN: {\n          target: 'dead',\n          actions: 'onDead',\n        },\n      },\n    },\n    dead: {\n      on: {\n        REVIVED: 'scatter',\n        ENERGIZER_TIMED_OUT: 'scatter',\n      },\n    },\n  },\n});\n\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\n  const extended = GhostStateChart.withConfig({\n    actions: {\n      onScatterToChase: eventHandler.onScatterToChase,\n      onChaseToScatter: eventHandler.onChaseToScatter,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { MilliSeconds } from './Types';\nimport { observable, computed, action } from 'mobx';\n\nexport type TimerCallback = () => void;\n\nexport class TimeoutTimer {\n  duration: MilliSeconds;\n  readonly onTimedOut: TimerCallback | null;\n\n  @observable\n  running: boolean;\n\n  @observable\n  timeSpent: MilliSeconds;\n\n  constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\n    this.duration = duration;\n    this.onTimedOut = onTimedOut;\n    this.running = false;\n    this.timeSpent = 0;\n  }\n\n  @action\n  setDuration(duration: MilliSeconds) {\n    this.duration = duration;\n  }\n\n  @action.bound\n  start() {\n    this.running = true;\n    this.timeSpent = 0;\n  }\n\n  @action\n  advance(timePassed: MilliSeconds) {\n    if (!this.running) {\n      return;\n    }\n    this.timeSpent += timePassed;\n    if (this.isTimedOut) {\n      this.onTimedOut?.();\n      this.stop();\n    }\n  }\n\n  @action\n  stop() {\n    this.running = false;\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  @computed\n  get timeLeft() {\n    return this.duration - this.timeSpent;\n  }\n\n  @computed\n  get isTimedOut() {\n    return this.timeSpent >= this.duration;\n  }\n}\n","import { action, computed, observable } from 'mobx';\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\nimport {\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n  tileFromScreen,\n} from './Coordinates';\nimport { findWayPoints } from './findWayPoints';\nimport { Game } from './Game';\nimport {\n  GhostEventType,\n  makeGhostStateChart,\n  GhostState,\n} from './GhostStateChart';\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  isTileInBox as isTileInBoxWalls,\n  isTileCenter,\n  isTileInBoxSpace,\n} from './Ways';\nimport { StateValue } from 'xstate';\nimport { TimeoutTimer } from './TimeoutTimer';\nimport { getStatePhaseLength } from './updateGhostStatePhase';\n\nexport type GhostNumber = 0 | 1 | 2 | 3;\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\nexport type GhostAnimationPhase = 0 | 1;\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\nexport type FrightenedGhostTime = 0 | 1;\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\n\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 3000;\n\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\n\nexport class Ghost {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleStateTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleStateTransition(state: GhostState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n    this.stateChanges++;\n  }\n\n  stateChart = makeGhostStateChart({\n    onScatterToChase: this.onScatterToChase,\n    onChaseToScatter: this.onChaseToScatter,\n    onDead: this.onDead,\n  });\n\n  @action.bound\n  onDead() {\n    this.game.killedGhosts++;\n    this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\n    this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\n  }\n\n  @action.bound\n  onScatterToChase() {\n    changeDirectionToOpposite(this);\n  }\n\n  @action.bound\n  onChaseToScatter() {\n    changeDirectionToOpposite(this);\n  }\n\n  @observable.ref\n  stateChartState: GhostState = this.stateChart.state;\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  @observable\n  stateChanges = 0;\n\n  @computed\n  get dead() {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @computed get frightened(): boolean {\n    return this.stateChartState.matches('frightened');\n  }\n\n  name = 'ghost name';\n\n  send(event: GhostEventType) {\n    this.stateChart.send(event);\n  }\n\n  @observable\n  ghostPaused = true;\n\n  game: Game;\n\n  @observable\n  ghostNumber: GhostNumber = 0;\n\n  color = 'ghost color';\n  colorCode = '#00ffff';\n\n  @observable\n  screenCoordinates: ScreenCoordinates = {\n    x: 16,\n    y: 16,\n  };\n\n  @computed\n  get atTileCenter(): boolean {\n    return isTileCenter(this.screenCoordinates);\n  }\n\n  @observable\n  speedFactor = 1;\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @computed\n  get animationPhase(): GhostAnimationPhase {\n    return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) %\n      2 ===\n      0\n      ? 0\n      : 1;\n  }\n\n  @computed\n  get frightenedAboutToEnd(): boolean {\n    return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\n  }\n\n  @observable\n  deadWaitingTimeInBoxLeft: MilliSeconds = 0;\n\n  @computed\n  get frightenedGhostTime(): FrightenedGhostTime {\n    if (!this.frightenedAboutToEnd) {\n      return 0;\n    }\n    // Blink every 0.5 seconds\n    return this.game.timestamp % 1000 < 500 ? 0 : 1;\n  }\n\n  @observable\n  direction: Direction = 'LEFT';\n\n  @observable\n  targetTile: TileCoordinates = { x: 1, y: 1 };\n\n  @computed\n  get wayPoints(): TileCoordinates[] | null {\n    return findWayPoints(\n      this.tileCoordinates,\n      this.targetTile,\n      this.direction,\n      this.canPassThroughBoxDoor\n    );\n  }\n\n  statePhaseTimer = new TimeoutTimer(3000);\n\n  @computed\n  get isInsideBoxWalls(): boolean {\n    return isTileInBoxWalls(this.tileCoordinates);\n  }\n\n  @computed\n  get isOutsideBoxSpace() {\n    return !isTileInBoxSpace(this.tileCoordinates);\n  }\n\n  @computed\n  get canPassThroughBoxDoor(): boolean {\n    if (this.alive) {\n      if (this.isInsideBoxWalls) {\n        if (this.game.timestamp > this.initialWaitingTimeInBox) {\n          return true;\n        }\n      }\n    }\n\n    if (this.dead) {\n      if (this.isOutsideBoxSpace) {\n        return true;\n      }\n\n      // Dead && Inside box\n      if (this.deadWaitingTimeInBoxLeft <= 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  @action\n  resetGhost() {\n    this.ghostPaused = false;\n    this.send('RESET');\n    this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\n    this.statePhaseTimer.restart();\n  }\n\n  initialWaitingTimeInBox = 0;\n}\n","import { TileCoordinates } from './Coordinates';\nimport { Direction } from './Types';\nimport { isEqual } from 'lodash';\nimport { chooseNextTile } from './chooseNextTile';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\n\nexport const findWayPoints = (\n  origin: TileCoordinates,\n  destination: TileCoordinates,\n  currentDirection: Direction,\n  boxDoorIsOpen: boolean\n): TileCoordinates[] | null => {\n  const way: TileCoordinates[] = [origin];\n  let currentTile = origin;\n  let workingDirection = currentDirection;\n  while (!isEqual(currentTile, destination)) {\n    const nextTile = chooseNextTile({\n      currentTile,\n      currentDirection: workingDirection,\n      targetTile: destination,\n      boxDoorIsOpen,\n    });\n    // Prevent endless iteration\n    if (way.some(wayPoint => isEqual(wayPoint, nextTile))) {\n      return way;\n    }\n    way.push(nextTile);\n    workingDirection = getDirectionFromTileToTile(\n      currentTile,\n      nextTile\n    ) as Direction;\n    currentTile = nextTile;\n  }\n  return way;\n};\n","import { Game } from './Game';\nimport { Ghost } from './Ghost';\n\nexport const resetGhosts = (ghosts: Ghost[]) => {\n  ghosts[0].setTileCoordinates({ x: 12, y: 14 });\n  ghosts[0].direction = 'LEFT';\n  ghosts[1].setTileCoordinates({ x: 13, y: 14 });\n  ghosts[1].direction = 'RIGHT';\n  ghosts[2].setTileCoordinates({ x: 14, y: 14 });\n  ghosts[3].direction = 'LEFT';\n  ghosts[3].setTileCoordinates({ x: 15, y: 14 });\n  ghosts[3].direction = 'RIGHT';\n\n  for (const ghost of ghosts) {\n    ghost.resetGhost();\n  }\n};\n\nexport const makeGhosts = (game: Game): Ghost[] => {\n  const ghosts: Ghost[] = [\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n  ];\n\n  ghosts[0].ghostNumber = 0;\n  ghosts[0].name = 'Blinky';\n  ghosts[0].color = 'red';\n  ghosts[0].colorCode = '#ff0000';\n  ghosts[0].initialWaitingTimeInBox = 1000;\n\n  ghosts[1].ghostNumber = 1;\n  ghosts[1].name = 'Pinky';\n  ghosts[1].color = 'pink';\n  ghosts[1].colorCode = '#fcb5ff';\n  ghosts[1].initialWaitingTimeInBox = 1300;\n\n  ghosts[2].ghostNumber = 2;\n  ghosts[2].name = 'Inky';\n  ghosts[2].color = 'blue';\n  ghosts[2].colorCode = '#00ffff';\n  ghosts[2].initialWaitingTimeInBox = 1600;\n\n  ghosts[3].ghostNumber = 3;\n  ghosts[3].name = 'Clyde';\n  ghosts[3].color = 'orange';\n  ghosts[3].colorCode = '#f9ba55';\n  ghosts[3].initialWaitingTimeInBox = 1900;\n\n  resetGhosts(ghosts);\n\n  return ghosts;\n};\n","import { observable } from 'mobx';\nimport { getPillsMatrix, TileId } from './MazeData';\n\nexport class Maze {\n  @observable\n  pills: TileId[][] = getPillsMatrix();\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_PACMAN_STATE = 'eating';\n\ninterface EventHandler {\n  onChasing(): void;\n  onDead(): void;\n}\n\ntype PacManContext = {};\n\ninterface PacManStateSchema {\n  states: {\n    eating: {};\n    chasing: {};\n    dead: {};\n  };\n}\n\nexport type PacManEventType =\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'COLLISION_WITH_GHOST'\n  | 'REVIVED';\n\ntype PacManEvent = { type: PacManEventType };\n\nexport type PacManState = State<\n  PacManContext,\n  PacManEvent,\n  PacManStateSchema,\n  any\n>;\n\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>(\n  {\n    id: 'pac-man',\n    initial: INITIAL_PACMAN_STATE,\n    states: {\n      eating: {\n        on: {\n          ENERGIZER_EATEN: 'chasing',\n          COLLISION_WITH_GHOST: 'dead',\n        },\n      },\n      chasing: {\n        entry: 'onChasing',\n        on: {\n          ENERGIZER_TIMED_OUT: 'eating',\n        },\n      },\n      dead: {\n        entry: 'onDead',\n        on: {\n          REVIVED: 'eating',\n        },\n      },\n    },\n  }\n);\n\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\n  const extended = PacManStateChart.withConfig({\n    actions: {\n      onChasing: eventHandler.onChasing,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { observable, action, computed } from 'mobx';\n\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  tileFromScreen,\n  screenFromTile,\n  TileCoordinates,\n  ScreenCoordinates,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport {\n  makePacManStateChart,\n  PacManEventType,\n  INITIAL_PACMAN_STATE,\n  PacManState,\n} from './PacManStateChart';\nimport { Game } from './Game';\nimport { StateValue } from 'xstate';\n\nexport class PacMan {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleTransition(state: PacManState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n  }\n\n  game: Game;\n\n  stateChart = makePacManStateChart({\n    onChasing: this.onChasing,\n    onDead: this.onDead,\n  });\n\n  @observable.ref\n  stateChartState: PacManState = this.stateChart.state;\n\n  @action.bound\n  onChasing() {\n    this.game.energizerTimer.start();\n  }\n\n  @action.bound\n  onDead() {\n    this.diedAtTimestamp = this.game.timestamp;\n  }\n\n  @computed\n  get dead(): boolean {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  send(event: PacManEventType) {\n    this.stateChart.send(event);\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @observable\n  screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    assertValidTileCoordinates(tile);\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @observable\n  diedAtTimestamp: MilliSeconds = -1;\n\n  @computed\n  get timeSinceDeath(): MilliSeconds {\n    if (this.alive) {\n      return 0;\n    }\n    return this.game.timestamp - this.diedAtTimestamp;\n  }\n\n  @observable\n  extraLivesLeft = 2;\n\n  @observable\n  direction: Direction = 'RIGHT';\n  nextDirection: Direction = 'RIGHT';\n}\n\nexport const resetPacMan = (pacMan: PacMan) => {\n  pacMan.diedAtTimestamp = -1;\n  pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\n  pacMan.setTileCoordinates({ x: 14, y: 23 });\n  pacMan.nextDirection = 'LEFT';\n  pacMan.direction = 'LEFT';\n};\n","import { action, computed, observable } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { makeGhosts, resetGhosts } from './makeGhosts';\nimport { Maze } from './Maze';\nimport { PacMan, resetPacMan } from './PacMan';\nimport { MilliSeconds, PixelsPerFrame } from './Types';\nimport { Store } from './Store';\nimport { TimeoutTimer } from './TimeoutTimer';\n\nexport const DEFAULT_SPEED = 2;\n\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\n\nexport class Game {\n  constructor(store: Store) {\n    this.store = store;\n    this.pacMan = new PacMan(this);\n    this.ghosts = makeGhosts(this);\n  }\n\n  store: Store;\n\n  //** The timestamp we got from requestAnimationFrame().\n  @observable\n  externalTimeStamp: MilliSeconds | null = null;\n\n  @observable\n  timestamp: MilliSeconds = 0;\n\n  @observable\n  lastFrameLength: MilliSeconds = 17;\n\n  @observable\n  frameCount = 0;\n\n  @observable\n  gamePaused = false;\n\n  speed: PixelsPerFrame = DEFAULT_SPEED;\n\n  ghosts: Ghost[];\n\n  pacMan: PacMan;\n\n  @observable\n  score = 0;\n\n  @observable\n  killedGhosts = 0;\n\n  maze = new Maze();\n\n  @action.bound\n  revivePacMan() {\n    this.pacMan.send('REVIVED');\n    this.timestamp = 0;\n    resetPacMan(this.pacMan);\n    resetGhosts(this.ghosts);\n  }\n\n  @computed\n  get gameOver(): boolean {\n    const pacMan = this.pacMan;\n    return pacMan.dead && pacMan.extraLivesLeft === 0;\n  }\n\n  energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\n    this.handleEnergizerTimedOut();\n  });\n\n  @action\n  handleEnergizerTimedOut() {\n    this.pacMan.send('ENERGIZER_TIMED_OUT');\n    for (const ghost of this.ghosts) {\n      ghost.send('ENERGIZER_TIMED_OUT');\n    }\n  }\n\n  readyGameForPlay() {\n    resetPacMan(this.pacMan);\n  }\n}\n","import { observable } from 'mobx';\nimport { Store } from './Store';\nimport { GhostViewOptions } from './GhostViewOptions';\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\nimport { GameViewOptions } from './GameViewOptions';\n\nexport class DebugState {\n  constructor(store: Store) {\n    this.store = store;\n  }\n\n  store: Store;\n\n  @observable\n  gameViewOptions: GameViewOptions = {\n    hitBox: false,\n  };\n\n  @observable\n  ghostViewOptions: GhostViewOptions = {\n    target: false,\n    wayPoints: false,\n  };\n\n  @observable\n  pacManViewOptions: PacManViewOptions = {\n    somePlaceholder: false,\n  };\n}\n","import { observable, action } from 'mobx';\nimport { Game } from './Game';\nimport { DebugState } from './DebugState';\n\nexport class Store {\n  @observable\n  game: Game = new Game(this);\n\n  debugState = new DebugState(this);\n\n  @action.bound\n  resetGame() {\n    this.game = new Game(this);\n    this.game.readyGameForPlay();\n  }\n}\n","import  { FC, ComponentType } from 'react';\nimport 'antd/dist/antd.compact.css';\n\nimport './GlobalStyles.css';\nimport { GamePage } from './pages/GamePage/GamePage';\nimport { Store } from './model/Store';\nimport { StoreProvider } from './components/StoreContext';\n\nconst PacmanGame: FC<{ store?: Store; Router?: ComponentType }> = ({\n  store = new Store()\n}) => {\n  return (\n    <StoreProvider value={store}>\n        <div >\n        <GamePage />\n        </div>\n    </StoreProvider>\n  );\n};\n\nexport default PacmanGame;\n\n","import React from \"react\";\nimport { logout } from \"../utils/Auth\";\n\nconst Logout = () => {\n  const lg = () => {\n    logout();\n    document.location.href = \"/\";\n  };\n\n  return <div>{lg()}</div>;\n};\n\nexport default Logout;\n","import React from \"react\";\nimport \"./App.css\";\nimport Navbar from \"./Navbar\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Home from \"../pages/Home\";\nimport About from \"../pages/About\";\nimport Events from \"../pages/Events\";\nimport Teams from \"../pages/Teams\";\nimport Blogs from \"../pages/Blogs\";\nimport Games from \"../pages/Games\";\nimport Login from \"./Login\";\nimport PacmanGame from \"../games/pacman/PacmanGame\";\nimport Logout from \"../pages/Logout\";\n\nfunction App() {\n  return (\n    <Router>\n      <Navbar />\n      <Routes>\n        <Route path=\"/\" exact element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/events\" element={<Events />} />\n        <Route path=\"/teams\" element={<Teams />} />\n        <Route path=\"/blogs\" element={<Blogs />} />\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/games\" element={<Games />} />\n        <Route path=\"/games/pacman\" element={<PacmanGame />} />\n        <Route path=\"/logout\" element={<Logout />} />\n      </Routes>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}