{"version":3,"sources":["games/pacman-game/components/Board.tsx","games/pacman-game/util/assert.ts","games/pacman-game/components/StoreContext.ts","games/pacman-game/model/MapGen.ts","games/pacman-game/model/Maze.ts","games/pacman-game/model/Coordinates.ts","games/pacman-game/components/Sprite.tsx","games/pacman-game/components/Box.tsx","games/pacman-game/model/collisionDetection.ts","games/pacman-game/model/eatEnergizer.ts","games/pacman-game/model/detectCollisions.ts","games/pacman-game/model/pacManDyingPhase.ts","games/pacman-game/pages/GamePage/components/PacManView.tsx","games/pacman-game/pages/GamePage/components/ExtraLives.tsx","games/pacman-game/pages/GamePage/components/Message.tsx","games/pacman-game/pages/GamePage/components/GameOver.tsx","games/pacman-game/pages/WayFindingPage/WayPoint.tsx","games/pacman-game/model/getDirectionFromTileToTile.ts","games/pacman-game/pages/WayFindingPage/WayPoints.tsx","games/pacman-game/pages/GamePage/components/Target.tsx","games/pacman-game/pages/GamePage/components/GhostsView.tsx","games/pacman-game/pages/GamePage/components/Map.ts","games/pacman-game/pages/GamePage/components/MazeCanvas.tsx","games/pacman-game/pages/GamePage/components/MazeView.tsx","games/pacman-game/pages/GamePage/components/PillsView.tsx","games/pacman-game/pages/GamePage/components/Score.tsx","games/pacman-game/components/Spacer.tsx","games/pacman-game/model/Types.ts","games/pacman-game/model/Vector.ts","games/pacman-game/model/Ways.ts","games/pacman-game/model/getTileDistance.ts","games/pacman-game/model/chooseNewTargetTile.ts","games/pacman-game/model/chooseNextTile.ts","games/pacman-game/model/updateGhostStatePhase.ts","games/pacman-game/model/updateGhosts.ts","games/pacman-game/model/movePacManBy.ts","games/pacman-game/model/updatePacMan.ts","games/pacman-game/model/onAnimationFrame.ts","games/pacman-game/model/updateExternalTimeStamp.ts","games/pacman-game/model/updateGameTimestamp.ts","games/pacman-game/model/updateEnergizerTimer.ts","games/pacman-game/model/useGameLoop.ts","games/pacman-game/model/useAnimationLoop.ts","games/pacman-game/pages/GamePage/GamePage.tsx","games/pacman-game/pages/GamePage/components/useKeyboardActions.ts","games/pacman-game/model/changeDirectionToOpposite.ts","games/pacman-game/model/GhostStateChart.ts","games/pacman-game/model/TimeoutTimer.ts","games/pacman-game/model/Ghost.ts","games/pacman-game/model/findWayPoints.ts","games/pacman-game/model/makeGhosts.ts","games/pacman-game/model/PacManStateChart.ts","games/pacman-game/model/PacMan.ts","games/pacman-game/model/Game.ts","games/pacman-game/model/DebugState.ts","games/pacman-game/model/Store.ts","games/pacman-game/Pacman.tsx","games/pacman-game/index.js"],"names":["Board","className","children","classNames","assert","condition","msg","Error","StoreContext","createContext","StoreProvider","Provider","useStore","store","useContext","useGame","game","MapGen","getRandomInt","min","max","Math","floor","random","shuffle","list","i","j","temp","len","length","this","randomElement","cells","tallRows","narrowCols","rows","cols","reset","x","y","filled","connect","next","no","undefined","group","c","genRandom","scope","getLeftMostEmptyCells","leftCells","push","isOpenCell","cell","prevDir","size","getOpenCells","openCells","numOpenCells","connectCell","dir","gen","newCell","firstCell","numGroups","numFilled","probStopGrowingAtSize","singleCount","longPieces","fillCell","isRaiseHeightCandidate","stop","dirs","result","dirs1","dirsLength","setResizeCandidates","q","c2","q2","isShrinkWidthCandidate","cellIsCrossCenter","isDesirable","g","isHori","q1","isVert","canRaiseHeight","y0","candidates","numCandidates","raiseHeight","chooseTallRows","canShrinkWidth","x0","shrinkWidth","chooseNarrowCols","setUpScaleCoords","final_x","final_y","final_w","final_h","createTunnels","upDead","downDead","singleDeadEndCells","topSingleDeadEndCells","botSingleDeadEndCells","voidTunnelCells","topVoidTunnelCells","botVoidTunnelCells","edgeTunnelCells","topEdgeTunnelCells","botEdgeTunnelCells","doubleDeadEndCells","numTunnelsCreated","isEdgeTunnelCandidate","isVoidTunnelCandidate","isSingleDeadEndCandidate","singleDeadEndDir","offset","isDoubleDeadEndCandidate","exit","topy","numTunnelsDesired","selectSingleDeadEnd","topTunnel","replaceGroup","oldg","newg","joinWalls","isJoinCandidate","getTiles","cl","cu","tiles","tileCells","subrows","subcols","midcols","fullcols","setTile","v","getTile","setTileCell","getTileCell","range","x1","miny","maxy","getTopEnergizerRange","getBotEnergizerRange","eraseUntilIntersection","adj","join","mapgen","console","log","MAZE_WIDTH_IN_TILES","MAZE_HEIGHT_IN_TILES","Maze","combineMap","buildGame","pills","parsePillMatrix","ways","parseWayMatrix","data","tileMatrix","Array","dataIndex","ty","tx","tileId","flatTiles","observable","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER_VECTOR","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","scale","Sprite","spriteName","name","style","position","left","top","transform","transformOrigin","Box","rect","color","width","height","backgroundColor","zIndex","collide","rect1","rect2","eatEnergizer","action","score","killedGhosts","pacMan","send","ghosts","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","maze","eatPill","error","ghostCollidesWithPacMan","ghost","detectCollisions","dead","pillTile","tileCoordinates","pillHitBox","pacManHitBox","screenCoordinates","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","TotalPacManDyingAnimationLength","from","keys","PacManDyingPhaseLength","PacManView","observer","alive","direction","gameViewOptions","debugState","pacManAnimationPhase","getPacManAnimationPhase","dyingPhase","timeSinceDeath","PacManDyingPhaseCount","getPacManDyingPhase","hitBox","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","dyingPacManAnimationPhase","step","round","timestamp","PacManSprite","DyingPacManSprite","PacManHitBox","ExtraLives","Layout","times","extraLivesLeft","n","styled","div","Message","text","MessageStyled","span","GameOver","gameOver","POINTS","DirectionToAngle","DOWN","LEFT","UP","RIGHT","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","WayPoints","wayPoints","map","wayPoint","index","getDirection","indexToUse","fromTile","toTile","Target","SCREEN_TILE_CENTER","version","d","GhostsGameView","ghostViewOptions","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","ghostNumber","target","GhostView","colorCode","targetTile","animationPhase","state","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","setDirFromEnum","dirEnum","tileSize","Point","PacmanMap","numCols","numRows","numTiles","widthPixels","heightPixels","wallStrokeColor","resetCurrent","currentTiles","split","parseWalls","that","paths","visited","toIndex","edges","makePath","pad","point","lastPoint","turn","turnAround","init_tx","init_ty","init_dirEnum","path","getStartPoint","isFloorTile","px","a","PI","cos","s","sin","cx","cy","posToIndex","isFloorTileChar","draw","ctx","beginPath","clip","strokeStyle","lineWidth","moveTo","quadraticCurveTo","lineTo","drawPath","save","translate","fillStyle","font","textBaseline","fillText","restore","MazeCanvas","props","canvasRef","useRef","useEffect","canvas","current","context","getContext","clearRect","ref","MazeView","waysMatrix","BasicPillView","EnergizerView","PillView","PillsView","memo","_","displayName","Score","SIZE_MAPPING","small","medium","large","mappedSize","VSpace","Directions","assertValidDirection","includes","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","directionToVector","distance","moveFromTile","steps","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","getTileDistance","neighbourTile","dx","abs","dy","sqrt","pow","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","isInsideBoxWalls","chooseForGhost2InChaseState","to","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","filter","newDirection","chooseInDeadMode","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","JSON","stringify","possibleNextTile","distanceToTarget","bestCandidate","minBy","neighbourTileInCurrentDirection","isWayFreeForGhostAt","isBoxDoorAt","updateGhostStatePhaseTime","statePhaseTimer","advance","lastFrameLength","updateGhostStatePhase","atTileCenter","isTimedOut","setDuration","getStatePhaseLength","restart","updateGhost","ghostPaused","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","deadWaitingTimeInBoxLeft","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","canPassThroughBoxDoor","getGhostMovementVector","moveGhostBy","speed","movePacManBy","updateLivingPacMan","nextDirection","movePacMan","delta","directionAsVector","updateDeadPacMan","revivePacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","gamePaused","frameCount","updateGameTimestamp","energizerTimer","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","animate","requestAnimationFrame","cancelAnimationFrame","useAnimationLoop","GamePage","resetGame","onKeyDown","useCallback","event","pressedKey","key","toUpperCase","document","addEventListener","removeEventListener","useKeyboardActions","ScoreArea","justify","EmptyArea","BoardArea","changeDirectionToOpposite","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","actions","COLLISION_WITH_PAC_MAN","scatter","frightened","ENERGIZER_TIMED_OUT","REVIVED","TimeoutTimer","bound","duration","onTimedOut","running","timeSpent","timePassed","start","computed","KILL_GHOST_SCORE","Ghost","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","stateChanges","value","matches","timeLeft","frightenedAboutToEnd","origin","destination","way","workingDirection","some","findWayPoints","isOutsideBoxSpace","resetGhosts","setTileCoordinates","resetGhost","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","handleTransition","diedAtTimestamp","resetPacMan","Game","handleEnergizerTimedOut","makeGhosts","DebugState","somePlaceholder","Store","readyGameForPlay","Pacman","RemixGame","Button","variant","component","Link","PacmanGame","MainCard","title","secondary"],"mappings":"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","file":"static/js/10.efac114e.chunk.js","sourcesContent":["import React from 'react';\nimport './Board.css';\nimport classNames from 'classnames';\n\nexport const Board: React.FC<{ className?: string }> = ({ className, children }) => (\n    <div className={classNames('Board', className)}>{children}</div>\n);\n","export function assert(condition: any, msg?: string): asserts condition {\n    if (!condition) {\n        throw new Error(`Assertion error ${msg ?? ''}`);\n    }\n}\n","import { createContext, useContext } from 'react';\nimport { Game } from '../model/Game';\nimport { assert } from '../util/assert';\nimport { Store } from '../model/Store';\n\nexport const StoreContext = createContext<Store | null>(null);\n\nexport const StoreProvider = StoreContext.Provider;\n\nexport const useStore = (): Store => {\n    const store = useContext(StoreContext);\n    assert(store, 'Store not provided - use <StoreProvider>');\n    return store;\n};\n\nexport const useGame = (): Game => {\n    const store = useStore();\n    return store.game;\n};\n","const UP = 0;\nconst RIGHT = 1;\nconst DOWN = 2;\nconst LEFT = 3;\n\nexport class MapGen{\n    getRandomInt = function(min,max) {\n        return Math.floor(Math.random() * (max-min+1)) + min;\n    };\n    \n    shuffle = function(list) {\n        var len = list.length;\n        var i,j;\n        var temp;\n        for (i=0; i<len; i++) {\n            j = this.getRandomInt(0,len-1);\n            temp = list[i];\n            list[i] = list[j];\n            list[j] = temp;\n        }\n    };\n    \n    randomElement = function(list) {\n        var len = list.length;\n        if (len > 0) {\n            return list[this.getRandomInt(0,len-1)];\n        }\n    };\n\n    \n    cells = [];\n    tallRows = [];\n    narrowCols = [];\n    rows = 9;\n    cols = 5;\n    \n    reset = function() {\n        var i;\n        var c;\n    \n        // initialize cells\n        for (i=0; i<this.rows*this.cols; i++) {\n            this.cells[i] = {\n                x: i%this.cols,\n                y: Math.floor(i/this.cols),\n                filled: false,\n                connect: [false, false, false, false],\n                next: [],\n                no: undefined,\n                group: undefined,\n            };\n        }\n    \n        // allow each cell to refer to surround cells by direction\n        for (i=0; i<this.rows*this.cols; i++) {\n            var c = this.cells[i];\n            if (c.x > 0)\n                c.next[LEFT] = this.cells[i-1];\n            if (c.x < this.cols - 1)\n                c.next[RIGHT] = this.cells[i+1];\n            if (c.y > 0)\n                c.next[UP] = this.cells[i-this.cols];\n            if (c.y < this.rows - 1)\n                c.next[DOWN] = this.cells[i+this.cols];\n        }\n    \n        // define the ghost home square\n    \n        i = 3*this.cols;\n        c = this.cells[i];\n        c.filled=true;\n        c.connect[LEFT] = c.connect[RIGHT] = c.connect[DOWN] = true;\n    \n        i++;\n        c = this.cells[i];\n        c.filled=true;\n        c.connect[LEFT] = c.connect[DOWN] = true;\n    \n        i+=this.cols-1;\n        c = this.cells[i];\n        c.filled=true;\n        c.connect[LEFT] = c.connect[UP] = c.connect[RIGHT] = true;\n    \n        i++;\n        c = this.cells[i];\n        c.filled=true;\n        c.connect[UP] = c.connect[LEFT] = true;\n    };\n    \n    genRandom = function() {\n    \n        const scope = this;\n        const getLeftMostEmptyCells = () => {\n            var x,y;\n            var leftCells = [];\n            for (x=0; x<scope.cols; x++) {\n                for (y=0; y<scope.rows; y++) {\n                    var c = scope.cells[x+y*scope.cols];\n                    if (!c.filled) {\n                        leftCells.push(c);\n                    }\n                }\n    \n                if (leftCells.length > 0) {\n                    break;\n                }\n            }\n            return leftCells;\n        };\n        const isOpenCell = (cell,i,prevDir,size) => {\n    \n            // prevent wall from going through starting position\n            if (cell.y == 6 && cell.x == 0 && i == DOWN ||\n                cell.y == 7 && cell.x == 0 && i == UP) {\n                return false;\n            }\n    \n            // prevent long straight pieces of length 3\n            if (size == 2 && (i==prevDir || (i+2)%4==prevDir)) {\n                return false;\n            }\n    \n            // examine an adjacent empty cell\n            if (cell.next[i] && !cell.next[i].filled) {\n                \n                // only open if the cell to the left of it is filled\n                if (cell.next[i].next[LEFT] && !cell.next[i].next[LEFT].filled) {\n                }\n                else {\n                    return true;\n                }\n            }\n    \n            return false;\n        };\n        var getOpenCells = function(cell,prevDir,size) {\n            var openCells = [];\n            var numOpenCells = 0;\n            for (var i=0; i<4; i++) {\n                if (isOpenCell(cell,i,prevDir,size)) {\n                    openCells.push(i);\n                    numOpenCells++;\n                }\n            }\n            return { openCells: openCells, numOpenCells: numOpenCells };\n        };\n        var connectCell = function(cell,dir) {\n            cell.connect[dir] = true;\n            cell.next[dir].connect[(dir+2)%4] = true;\n            if (cell.x == 0 && dir == RIGHT) {\n                cell.connect[LEFT] = true;\n            }\n        };\n    \n        var gen = function() {\n        \n            var cell;      // cell at the center of growth (open cells are chosen around this cell)\n            var newCell;   // most recent cell filled\n            var firstCell; // the starting cell of the current group\n    \n            var openCells;    // list of open cells around the center cell\n            var numOpenCells; // size of openCells\n    \n            var dir; // the most recent direction of growth relative to the center cell\n            var i;   // loop control variable used for iterating directions\n    \n            var numFilled = 0;  // current count of total cells filled\n            var numGroups;      // current count of cell groups created\n            var size;           // current number of cells in the current group\n            var probStopGrowingAtSize = [ // probability of stopping growth at sizes...\n                    0,     // size 0\n                    0,     // size 1\n                    0.10,  // size 2\n                    0.5,   // size 3\n                    0.75,  // size 4\n                    1];    // size 5\n    \n            // A single cell group of size 1 is allowed at each row at y=0 and y=rows-1,\n            // so keep count of those created.\n            var singleCount = {};\n            singleCount[0] = singleCount[scope.rows-1] = 0;\n            var probTopAndBotSingleCellJoin = 0.35;\n    \n            // A count and limit of the number long pieces (i.e. an \"L\" of size 4 or \"T\" of size 5)\n            var longPieces = 0;\n            var maxLongPieces = 1;\n            var probExtendAtSize2 = 1;\n            var probExtendAtSize3or4 = 0.5;\n    \n            var fillCell = function(cell) {\n                cell.filled = true;\n                cell.no = numFilled++;\n                cell.group = numGroups;\n            };\n    \n            for (numGroups=0; ; numGroups++) {\n    \n                // find all the leftmost empty cells\n                openCells = getLeftMostEmptyCells();\n    \n                // stop add pieces if there are no more empty cells.\n                numOpenCells = openCells.length;\n                if (numOpenCells == 0) {\n                    break;\n                }\n    \n                // choose the center cell to be a random open cell, and fill it.\n                firstCell = cell = openCells[scope.getRandomInt(0,numOpenCells-1)];\n                fillCell(cell);\n    \n                // randomly allow one single-cell piece on the top or bottom of the map.\n                if (cell.x < scope.cols-1 && (cell.y in singleCount) && Math.random() <= probTopAndBotSingleCellJoin) {\n                    if (singleCount[cell.y] == 0) {\n                        cell.connect[cell.y == 0 ? UP : DOWN] = true;\n                        singleCount[cell.y]++;\n                        continue;\n                    }\n                }\n    \n                // number of cells in this contiguous group\n                size = 1;\n    \n                if (cell.x == scope.cols-1) {\n                    // if the first cell is at the right edge, then don't grow it.\n                    cell.connect[RIGHT] = true;\n                    cell.isRaiseHeightCandidate = true;\n                }\n                else {\n                    // only allow the piece to grow to 5 cells at most.\n                    while (size < 5) {\n    \n                        var stop = false;\n    \n                        if (size == 2) {\n                            // With a horizontal 2-cell group, try to turn it into a 4-cell \"L\" group.\n                            // This is done here because this case cannot be reached when a piece has already grown to size 3.\n                            var c = firstCell;\n                            if (c.x > 0 && c.connect[RIGHT] && c.next[RIGHT] && c.next[RIGHT].next[RIGHT]) {\n                                if (longPieces < maxLongPieces && Math.random() <= probExtendAtSize2) {\n    \n                                    c = c.next[RIGHT].next[RIGHT];\n                                    var dirs = {};\n                                    if (isOpenCell(c,UP, null, null)) {\n                                        dirs[UP] = true;\n                                    }\n                                    if (isOpenCell(c,DOWN, null, null)) {\n                                        dirs[DOWN] = true;\n                                    }\n    \n                                    if (dirs[UP] && dirs[DOWN]) {\n                                        i = [UP,DOWN][scope.getRandomInt(0,1)];\n                                    }\n                                    else if (dirs[UP]) {\n                                        i = UP;\n                                    }\n                                    else if (dirs[DOWN]) {\n                                        i = DOWN;\n                                    }\n                                    else {\n                                        i = undefined;\n                                    }\n    \n                                    if (i != undefined) {\n                                        connectCell(c,LEFT);\n                                        fillCell(c);\n                                        connectCell(c,i);\n                                        fillCell(c.next[i]);\n                                        longPieces++;\n                                        size+=2;\n                                        stop = true;\n                                    }\n                                }\n                            }\n                        }\n    \n                        if (!stop) {\n                            // find available open adjacent cells.\n                            var result = getOpenCells(cell,dir,size);\n                            openCells = result['openCells'];\n                            numOpenCells = result['numOpenCells'];\n    \n                            // if no open cells found from center point, then use the last cell as the new center\n                            // but only do this if we are of length 2 to prevent numerous short pieces.\n                            // then recalculate the open adjacent cells.\n                            if (numOpenCells == 0 && size == 2) {\n                                cell = newCell;\n                                result = getOpenCells(cell,dir,size);\n                                openCells = result['openCells'];\n                                numOpenCells = result['numOpenCells'];\n                            }\n    \n                            // no more adjacent cells, so stop growing this piece.\n                            if (numOpenCells == 0) {\n                                stop = true;\n                            }\n                            else {\n                                // choose a random valid direction to grow.\n                                dir = openCells[scope.getRandomInt(0,numOpenCells-1)];\n                                newCell = cell.next[dir];\n    \n                                // connect the cell to the new cell.\n                                connectCell(cell,dir);\n    \n                                // fill the cell\n                                fillCell(newCell);\n    \n                                // increase the size count of this piece.\n                                size++;\n    \n                                // don't let center pieces grow past 3 cells\n                                if (firstCell.x == 0 && size == 3) {\n                                    stop = true;\n                                }\n    \n                                // Use a probability to determine when to stop growing the piece.\n                                if (Math.random() <= probStopGrowingAtSize[size]) {\n                                    stop = true;\n                                }\n                            }\n                        }\n    \n                        // Close the piece.\n                        if (stop) {\n    \n                            if (size == 1) {\n                                // This is provably impossible because this loop is never entered with size==1.\n                            }\n                            else if (size == 2) {\n    \n                                // With a vertical 2-cell group, attach to the right wall if adjacent.\n                                var c = firstCell;\n                                if (c.x == scope.cols-1) {\n    \n                                    // select the top cell\n                                    if (c.connect[UP]) {\n                                        c = c.next[UP];\n                                    }\n                                    c.connect[RIGHT] = c.next[DOWN].connect[RIGHT] = true;\n                                }\n                                \n                            }\n                            else if (size == 3 || size == 4) {\n    \n                                // Try to extend group to have a long leg\n                                if (longPieces < maxLongPieces && firstCell.x > 0 && Math.random() <= probExtendAtSize3or4) {\n                                    // TODO: check her\n                                    var dirs1 = [];\n                                    var dirsLength = 0;\n                                    let i:number = 0;\n                                    for (i=0; i<4; i++) {\n                                        if (cell.connect[i] && isOpenCell(cell.next[i],i,null, null)) {\n                                            dirs1.push(i);\n                                            dirsLength++;\n                                        }\n                                    }\n                                    if (dirsLength > 0) {\n                                        i = dirs1[scope.getRandomInt(0,dirsLength-1)];\n                                        c = cell.next[i];\n                                        connectCell(c,i);\n                                        fillCell(c.next[i]);\n                                        longPieces++;\n                                    }\n                                }\n                            }\n    \n                            break;\n                        }\n                    }\n                }\n            }\n            setResizeCandidates();\n        };\n    \n    \n        var setResizeCandidates = function() {\n            var i;\n            var c,q,c2,q2;\n            var x,y;\n            for (i=0; i<scope.rows*scope.cols; i++) {\n                c = scope.cells[i];\n                x = i % scope.cols;\n                y = Math.floor(i/scope.cols);\n    \n                // determine if it has flexible height\n    \n                //\n                // |_|\n                //\n                // or\n                //  _\n                // | |\n                //\n                q = c.connect;\n                if ((c.x == 0 || !q[LEFT]) &&\n                    (c.x == scope.cols-1 || !q[RIGHT]) &&\n                    q[UP] != q[DOWN]) {\n                    c.isRaiseHeightCandidate = true;\n                }\n    \n                //  _ _\n                // |_ _|\n                //\n                c2 = c.next[RIGHT];\n                if (c2 != undefined) {\n                    q2 = c2.connect;\n                    if (((c.x == 0 || !q[LEFT]) && !q[UP] && !q[DOWN]) &&\n                        ((c2.x == scope.cols-1 || !q2[RIGHT]) && !q2[UP] && !q2[DOWN])\n                        ) {\n                        c.isRaiseHeightCandidate = c2.isRaiseHeightCandidate = true;\n                    }\n                }\n    \n                // determine if it has flexible width\n    \n                // if cell is on the right edge with an opening to the right\n                if (c.x == scope.cols-1 && q[RIGHT]) {\n                    c.isShrinkWidthCandidate = true;\n                }\n    \n                //  _\n                // |_\n                // \n                // or\n                //  _\n                //  _|\n                //\n                if ((c.y == 0 || !q[UP]) &&\n                    (c.y == scope.rows-1 || !q[DOWN]) &&\n                    q[LEFT] != q[RIGHT]) {\n                    c.isShrinkWidthCandidate = true;\n                }\n    \n            }\n        };\n    \n        // Identify if a cell is the center of a cross.\n        var cellIsCrossCenter = function(c) {\n            return c.connect[UP] && c.connect[RIGHT] && c.connect[DOWN] && c.connect[LEFT];\n        };\n    \n        var chooseNarrowCols = function() {\n    \n            var canShrinkWidth = function(x,y) {\n    \n                // Can cause no more tight turns.\n                if (y==scope.rows-1) {\n                    return true;\n                }\n    \n                // get the right-hand-side bound\n                var x0;\n                var c,c2;\n                for (x0=x; x0<scope.cols; x0++) {\n                    c = scope.cells[x0+y*scope.cols];\n                    c2 = c.next[DOWN]\n                    if ((!c.connect[RIGHT] || cellIsCrossCenter(c)) &&\n                        (!c2.connect[RIGHT] || cellIsCrossCenter(c2))) {\n                        break;\n                    }\n                }\n    \n                // build candidate list\n                var candidates = [];\n                var numCandidates = 0;\n                for (; c2; c2=c2.next[LEFT]) {\n                    if (c2.isShrinkWidthCandidate) {\n                        candidates.push(c2);\n                        numCandidates++;\n                    }\n    \n                    // cannot proceed further without causing irreconcilable tight turns\n                    if ((!c2.connect[LEFT] || cellIsCrossCenter(c2)) &&\n                        (!c2.next[UP].connect[LEFT] || cellIsCrossCenter(c2.next[UP]))) {\n                        break;\n                    }\n                }\n                scope.shuffle(candidates);\n    \n                var i;\n                for (i=0; i<numCandidates; i++) {\n                    c2 = candidates[i];\n                    if (canShrinkWidth(c2.x,c2.y)) {\n                        c2.shrinkWidth = true;\n                        scope.narrowCols[c2.y] = c2.x;\n                        return true;\n                    }\n                }\n    \n                return false;\n            };\n    \n            var x;\n            var c;\n            for (x=scope.cols-1; x>=0; x--) {\n                c = scope.cells[x];\n                if (c.isShrinkWidthCandidate && canShrinkWidth(x,0)) {\n                    c.shrinkWidth = true;\n                    scope.narrowCols[c.y] = c.x;\n                    return true;\n                }\n            }\n    \n            return false;\n        };\n    \n        var chooseTallRows = function() {\n    \n            var canRaiseHeight = function(x,y) {\n    \n                // Can cause no more tight turns.\n                if (x==scope.cols-1) {\n                    return true;\n                }\n    \n                // find the first cell below that will create too tight a turn on the right\n                var y0;\n                var c;\n                var c2;\n                for (y0=y; y0>=0; y0--) {\n                    c = scope.cells[x+y0*scope.cols];\n                    c2 = c.next[RIGHT]\n                    if ((!c.connect[UP] || cellIsCrossCenter(c)) && \n                        (!c2.connect[UP] || cellIsCrossCenter(c2))) {\n                        break;\n                    }\n                }\n    \n                // Proceed from the right cell upwards, looking for a cell that can be raised.\n                var candidates = [];\n                var numCandidates = 0;\n                for (; c2; c2=c2.next[DOWN]) {\n                    if (c2.isRaiseHeightCandidate) {\n                        candidates.push(c2);\n                        numCandidates++;\n                    }\n    \n                    // cannot proceed further without causing irreconcilable tight turns\n                    if ((!c2.connect[DOWN] || cellIsCrossCenter(c2)) &&\n                        (!c2.next[LEFT].connect[DOWN] || cellIsCrossCenter(c2.next[LEFT]))) {\n                        break;\n                    }\n                }\n                scope.shuffle(candidates);\n    \n                var i;\n                for (i=0; i<numCandidates; i++) {\n                    c2 = candidates[i];\n                    if (canRaiseHeight(c2.x,c2.y)) {\n                        c2.raiseHeight = true;\n                        scope.tallRows[c2.x] = c2.y;\n                        return true;\n                    }\n                }\n    \n                return false;\n            };\n    \n            // From the top left, examine cells below until hitting top of ghost house.\n            // A raisable cell must be found before the ghost house.\n            var y;\n            var c;\n            for (y=0; y<3; y++) {\n                c = scope.cells[y*scope.cols];\n                if (c.isRaiseHeightCandidate && canRaiseHeight(0,y)) {\n                    c.raiseHeight = true;\n                    scope.tallRows[c.x] = c.y;\n                    return true;\n                }\n            }\n    \n            return false;\n        };\n    \n        // This is a function to detect impurities in the map that have no heuristic implemented to avoid it yet in gen().\n        var isDesirable = function() {\n    \n            // ensure a solid top right corner\n            var c = scope.cells[4];\n            if (c.connect[UP] || c.connect[RIGHT]) {\n                return false;\n            }\n    \n            // ensure a solid bottom right corner\n            c = scope.cells[scope.rows*scope.cols-1];\n            if (c.connect[DOWN] || c.connect[RIGHT]) {\n                return false;\n            }\n    \n            // ensure there are no two stacked/side-by-side 2-cell pieces.\n            var isHori = function(x,y) {\n                var q1 = scope.cells[x+y*scope.cols].connect;\n                var q2 = scope.cells[x+1+y*scope.cols].connect;\n                return !q1[UP] && !q1[DOWN] && (x==0 || !q1[LEFT]) && q1[RIGHT] && \n                       !q2[UP] && !q2[DOWN] && q2[LEFT] && !q2[RIGHT];\n            };\n            var isVert = function(x,y) {\n                var q1 = scope.cells[x+y*scope.cols].connect;\n                var q2 = scope.cells[x+(y+1)*scope.cols].connect;\n                if (x==scope.cols-1) {\n                    // special case (we can consider two single cells as vertical at the right edge)\n                    return !q1[LEFT] && !q1[UP] && !q1[DOWN] &&\n                           !q2[LEFT] && !q2[UP] && !q2[DOWN];\n                }\n                return !q1[LEFT] && !q1[RIGHT] && !q1[UP] && q1[DOWN] && \n                       !q2[LEFT] && !q2[RIGHT] && q2[UP] && !q2[DOWN];\n            };\n            var x,y;\n            var g;\n            for (y=0; y<scope.rows-1; y++) {\n                for (x=0; x<scope.cols-1; x++) {\n                    if (isHori(x,y) && isHori(x,y+1) ||\n                        isVert(x,y) && isVert(x+1,y)) {\n    \n                        // don't allow them in the middle because they'll be two large when reflected.\n                        if (x==0) {\n                            return false;\n                        }\n    \n                        // Join the four cells to create a square.\n                        scope.cells[x+y*scope.cols].connect[DOWN] = true;\n                        scope.cells[x+y*scope.cols].connect[RIGHT] = true;\n                        g = scope.cells[x+y*scope.cols].group;\n    \n                        scope.cells[x+1+y*scope.cols].connect[DOWN] = true;\n                        scope.cells[x+1+y*scope.cols].connect[LEFT] = true;\n                        scope.cells[x+1+y*scope.cols].group = g;\n    \n                        scope.cells[x+(y+1)*scope.cols].connect[UP] = true;\n                        scope.cells[x+(y+1)*scope.cols].connect[RIGHT] = true;\n                        scope.cells[x+(y+1)*scope.cols].group = g;\n    \n                        scope.cells[x+1+(y+1)*scope.cols].connect[UP] = true;\n                        scope.cells[x+1+(y+1)*scope.cols].connect[LEFT] = true;\n                        scope.cells[x+1+(y+1)*scope.cols].group = g;\n                    }\n                }\n            }\n    \n            if (!chooseTallRows()) {\n                return false;\n            }\n    \n            if (!chooseNarrowCols()) {\n                return false;\n            }\n    \n            return true;\n        };\n    \n        // set the final position and size of each cell when upscaling the simple model to actual size\n        var setUpScaleCoords = function() {\n            var i,c;\n            for (i=0; i<scope.rows*scope.cols; i++) {\n                c = scope.cells[i];\n                c.final_x = c.x*3;\n                if (scope.narrowCols[c.y] < c.x) {\n                    c.final_x--;\n                }\n                c.final_y = c.y*3;\n                if (scope.tallRows[c.x] < c.y) {\n                    c.final_y++;\n                }\n                c.final_w = c.shrinkWidth ? 2 : 3;\n                c.final_h = c.raiseHeight ? 4 : 3;\n            }\n        };\n    \n        var reassignGroup = function(oldg,newg) {\n            var i;\n            var c;\n            for (i=0; i<scope.rows*scope.cols; i++) {\n                c = scope.cells[i];\n                if (c.group == oldg) {\n                    c.group = newg;\n                }\n            }\n        };\n    \n        var createTunnels = function() {\n    \n            // declare candidates\n            var singleDeadEndCells = [];\n            var topSingleDeadEndCells = [];\n            var botSingleDeadEndCells = [];\n    \n            var voidTunnelCells = [];\n            var topVoidTunnelCells = [];\n            var botVoidTunnelCells = [];\n    \n            var edgeTunnelCells = [];\n            var topEdgeTunnelCells = [];\n            var botEdgeTunnelCells = [];\n    \n            var doubleDeadEndCells = [];\n    \n            var numTunnelsCreated = 0;\n    \n            // prepare candidates\n            var y;\n            var c;\n            var upDead;\n            var downDead;\n            for (y=0; y<scope.rows; y++) {\n                c = scope.cells[scope.cols-1+y*scope.cols];\n                if (c.connect[UP]) {\n                    continue;\n                }\n                if (c.y > 1 && c.y < scope.rows-2) {\n                    c.isEdgeTunnelCandidate = true;\n                    edgeTunnelCells.push(c);\n                    if (c.y <= 2) {\n                        topEdgeTunnelCells.push(c);\n                    }\n                    else if (c.y >= 5) {\n                        botEdgeTunnelCells.push(c);\n                    }\n                }\n                upDead = (!c.next[UP] || c.next[UP].connect[RIGHT]);\n                downDead = (!c.next[DOWN] || c.next[DOWN].connect[RIGHT]);\n                if (c.connect[RIGHT]) {\n                    if (upDead) {\n                        c.isVoidTunnelCandidate = true;\n                        voidTunnelCells.push(c);\n                        if (c.y <= 2) {\n                            topVoidTunnelCells.push(c);\n                        }\n                        else if (c.y >= 6) {\n                            botVoidTunnelCells.push(c);\n                        }\n                    }\n                }\n                else {\n                    if (c.connect[DOWN]) {\n                        continue;\n                    }\n                    if (upDead != downDead) {\n                        if (!c.raiseHeight && y < scope.rows-1 && !c.next[LEFT].connect[LEFT]) {\n                            singleDeadEndCells.push(c);\n                            c.isSingleDeadEndCandidate = true;\n                            c.singleDeadEndDir = upDead ? UP : DOWN;\n                            var offset = upDead ? 1 : 0;\n                            if (c.y <= 1+offset) {\n                                topSingleDeadEndCells.push(c);\n                            }\n                            else if (c.y >= 5+offset) {\n                                botSingleDeadEndCells.push(c);\n                            }\n                        }\n                    }\n                    else if (upDead && downDead) {\n                        if (y > 0 && y < scope.rows-1) {\n                            if (c.next[LEFT].connect[UP] && c.next[LEFT].connect[DOWN]) {\n                                c.isDoubleDeadEndCandidate = true;\n                                if (c.y >= 2 && c.y <= 5) {\n                                    doubleDeadEndCells.push(c);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n    \n            // choose tunnels from candidates\n            var numTunnelsDesired = Math.random() <= 0.45 ? 2 : 1;\n            var c;\n            var selectSingleDeadEnd = function(c) {\n                c.connect[RIGHT] = true;\n                if (c.singleDeadEndDir == UP) {\n                    c.topTunnel = true;\n                }\n                else {\n                    c.next[DOWN].topTunnel = true;\n                }\n            };\n            if (numTunnelsDesired == 1) {\n                if (c = scope.randomElement(voidTunnelCells)) {\n                    c.topTunnel = true;\n                }\n                else if (c = scope.randomElement(singleDeadEndCells)) {\n                    selectSingleDeadEnd(c);\n                }\n                else if (c = scope.randomElement(edgeTunnelCells)) {\n                    c.topTunnel = true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (numTunnelsDesired == 2) {\n                if (c = scope.randomElement(doubleDeadEndCells)) {\n                    c.connect[RIGHT] = true;\n                    c.topTunnel = true;\n                    c.next[DOWN].topTunnel = true;\n                }\n                else {\n                    numTunnelsCreated = 1;\n                    if (c = scope.randomElement(topVoidTunnelCells)) {\n                        c.topTunnel = true;\n                    }\n                    else if (c = scope.randomElement(topSingleDeadEndCells)) {\n                        selectSingleDeadEnd(c);\n                    }\n                    else if (c = scope.randomElement(topEdgeTunnelCells)) {\n                        c.topTunnel = true;\n                    }\n                    else {\n                        // could not find a top tunnel opening\n                        numTunnelsCreated = 0;\n                    }\n    \n                    if (c = scope.randomElement(botVoidTunnelCells)) {\n                        c.topTunnel = true;\n                    }\n                    else if (c = scope.randomElement(botSingleDeadEndCells)) {\n                        selectSingleDeadEnd(c);\n                    }\n                    else if (c = scope.randomElement(botEdgeTunnelCells)) {\n                        c.topTunnel = true;\n                    }\n                    else {\n                        // could not find a bottom tunnel opening\n                        if (numTunnelsCreated == 0) {\n                            return false;\n                        }\n                    }\n                }\n            }\n    \n            // don't allow a horizontal path to cut straight through a map (through tunnels)\n            var exit,topy;\n            for (y=0; y<scope.rows; y++) {\n                c = scope.cells[scope.cols-1+y*scope.cols];\n                if (c.topTunnel) {\n                    exit = true;\n                    topy = c.final_y;\n                    while (c.next[LEFT]) {\n                        c = c.next[LEFT];\n                        if (!c.connect[UP] && c.final_y == topy) {\n                            continue;\n                        }\n                        else {\n                            exit = false;\n                            break;\n                        }\n                    }\n                    if (exit) {\n                        return false;\n                    }\n                }\n            }\n    \n            // clear unused void tunnels (dead ends)\n            var len = voidTunnelCells.length;\n            var i;\n    \n            var replaceGroup = function(oldg,newg) {\n                var i,c;\n                for (i=0; i<scope.rows*scope.cols; i++) {\n                    c = scope.cells[i];\n                    if (c.group == oldg) {\n                        c.group = newg;\n                    }\n                }\n            };\n            for (i=0; i<len; i++) {\n                c = voidTunnelCells[i];\n                if (!c.topTunnel) {\n                    replaceGroup(c.group, c.next[UP].group);\n                    c.connect[UP] = true;\n                    c.next[UP].connect[DOWN] = true;\n                }\n            }\n    \n            return true;\n        };\n    \n        var joinWalls = function() {\n    \n            // randomly join wall pieces to the boundary to increase difficulty\n    \n            var x,y;\n            var c;\n    \n            // join cells to the top boundary\n            for (x=0; x<scope.cols; x++) {\n                c = scope.cells[x];\n                if (!c.connect[LEFT] && !c.connect[RIGHT] && !c.connect[UP] &&\n                    (!c.connect[DOWN] || !c.next[DOWN].connect[DOWN])) {\n    \n                    // ensure it will not create a dead-end\n                    if ((!c.next[LEFT] || !c.next[LEFT].connect[UP]) &&\n                        (c.next[RIGHT] && !c.next[RIGHT].connect[UP])) {\n    \n                        // prevent connecting very large piece\n                        if (!(c.next[DOWN] && c.next[DOWN].connect[RIGHT] && c.next[DOWN].next[RIGHT].connect[RIGHT])) {\n                            c.isJoinCandidate = true;\n                            if (Math.random() <= 0.25) {\n                                c.connect[UP] = true;\n                            }\n                        }\n                    }\n                }\n            }\n    \n            // join cells to the bottom boundary\n            for (x=0; x<scope.cols; x++) {\n                c = scope.cells[x+(scope.rows-1)*scope.cols];\n                if (!c.connect[LEFT] && !c.connect[RIGHT] && !c.connect[DOWN] &&\n                    (!c.connect[UP] || !c.next[UP].connect[UP])) {\n    \n                    // ensure it will not creat a dead-end\n                    if ((!c.next[LEFT] || !c.next[LEFT].connect[DOWN]) &&\n                        (c.next[RIGHT] && !c.next[RIGHT].connect[DOWN])) {\n    \n                        // prevent connecting very large piece\n                        if (!(c.next[UP] && c.next[UP].connect[RIGHT] && c.next[UP].next[RIGHT].connect[RIGHT])) {\n                            c.isJoinCandidate = true;\n                            if (Math.random() <= 0.25) {\n                                c.connect[DOWN] = true;\n                            }\n                        }\n                    }\n                }\n            }\n    \n            // join cells to the right boundary\n            var c2;\n            for (y=1; y<scope.rows-1; y++) {\n                c = scope.cells[scope.cols-1+y*scope.cols];\n                if (c.raiseHeight) {\n                    continue;\n                }\n                if (!c.connect[RIGHT] && !c.connect[UP] && !c.connect[DOWN] &&\n                    !c.next[UP].connect[RIGHT] && !c.next[DOWN].connect[RIGHT]) {\n                    if (c.connect[LEFT]) {\n                        c2 = c.next[LEFT];\n                        if (!c2.connect[UP] && !c2.connect[DOWN] && !c2.connect[LEFT]) {\n                            c.isJoinCandidate = true;\n                            if (Math.random() <= 0.5) {\n                                c.connect[RIGHT] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    \n        // try to generate a valid map, and keep count of tries.\n        var genCount = 0;\n        while (true) {\n            scope.reset();\n            gen();\n            genCount++;\n            if (!isDesirable()) {\n                continue;\n            }\n    \n            setUpScaleCoords();\n            joinWalls();\n            if (!createTunnels()) {\n                continue;\n            }\n    \n            break;\n        }\n    \n    };\n    \n    // Transform the simple cells to a tile array used for creating the map.\n    getTiles = function() {\n    \n        var tiles = []; // each is a character indicating a wall(|), path(.), or blank(_).\n        var tileCells = []; // maps each tile to a specific cell of our simple map\n        var subrows = this.rows*3+1+3;\n        var subcols = this.cols*3-1+2;\n    \n        var midcols = subcols-2;\n        var fullcols = (subcols-2)*2;\n    \n        // getter and setter for tiles (ensures vertical symmetry axis)\n        var setTile = function(x,y,v) {\n            if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {\n                return;\n            }\n            x -= 2;\n            tiles[midcols+x+y*fullcols] = v;\n            tiles[midcols-1-x+y*fullcols] = v;\n        };\n        var getTile = function(x,y) {\n            if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {\n                return undefined;\n            }\n            x -= 2;\n            return tiles[midcols+x+y*fullcols];\n        };\n    \n        // getter and setter for tile cells\n        var setTileCell = function(x,y,cell) {\n            if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {\n                return;\n            }\n            x -= 2;\n            tileCells[x+y*subcols] = cell;\n        };\n        var getTileCell = function(x,y) {\n            if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {\n                return undefined;\n            }\n            x -= 2;\n            return tileCells[x+y*subcols];\n        };\n    \n        // initialize tiles\n        var i;\n        for (i=0; i<subrows*fullcols; i++) {\n            tiles.push('_');\n        }\n        for (i=0; i<subrows*subcols; i++) {\n            tileCells.push(undefined);\n        }\n    \n        // set tile cells\n        var c;\n        var x,y,w,h;\n        var x0,y0;\n        for (i=0; i<this.rows*this.cols; i++) {\n            c = this.cells[i];\n            for (x0=0; x0<c.final_w; x0++) {\n                for (y0=0; y0<c.final_h; y0++) {\n                    setTileCell(c.final_x+x0,c.final_y+1+y0,c);\n                }\n            }\n        }\n    \n        // set path tiles\n        var cl, cu;\n        for (y=0; y<subrows; y++) {\n            for (x=0; x<subcols; x++) {\n                c = getTileCell(x,y); // cell\n                cl = getTileCell(x-1,y); // left cell\n                cu = getTileCell(x,y-1); // up cell\n    \n                if (c) {\n                    // inside map\n                    if (cl && c.group != cl.group || // at vertical boundary\n                        cu && c.group != cu.group || // at horizontal boundary\n                        !cu && !c.connect[UP]) { // at top boundary\n                        setTile(x,y,'.');\n                    }\n                }\n                else {\n                    // outside map\n                    if (cl && (!cl.connect[RIGHT] || getTile(x-1,y) == '.') || // at right boundary\n                        cu && (!cu.connect[DOWN] || getTile(x,y-1) == '.')) { // at bottom boundary\n                        setTile(x,y,'.');\n                    }\n                }\n    \n                // at corner connecting two paths\n                if (getTile(x-1,y) == '.' && getTile(x,y-1) == '.' && getTile(x-1,y-1) == '_') {\n                    setTile(x,y,'.');\n                }\n            }\n        }\n    \n        // extend tunnels\n        var y;\n        for (c=this.cells[this.cols-1]; c; c = c.next[DOWN]) {\n            if (c.topTunnel) {\n                y = c.final_y+1;\n                setTile(subcols-1, y,'.');\n                setTile(subcols-2, y,'.');\n            }\n        }\n    \n        // fill in walls\n        for (y=0; y<subrows; y++) {\n            for (x=0; x<subcols; x++) {\n                // any blank tile that shares a vertex with a path tile should be a wall tile\n                if (getTile(x,y) != '.' && (getTile(x-1,y) == '.' || getTile(x,y-1) == '.' || getTile(x+1,y) == '.' || getTile(x,y+1) == '.' ||\n                    getTile(x-1,y-1) == '.' || getTile(x+1,y-1) == '.' || getTile(x+1,y+1) == '.' || getTile(x-1,y+1) == '.')) {\n                    setTile(x,y,'|');\n                }\n            }\n        }\n    \n        // create the ghost door\n        setTile(2,12,'-');\n    \n        // set energizers\n        var getTopEnergizerRange = function() {\n            var miny;\n            var maxy = subrows/2;\n            var x = subcols-2;\n            var y;\n            for (y=2; y<maxy; y++) {\n                if (getTile(x,y) == '.' && getTile(x,y+1) == '.') {\n                    miny = y+1;\n                    break;\n                }\n            }\n            maxy = Math.min(maxy,miny+7);\n            for (y=miny+1; y<maxy; y++) {\n                if (getTile(x-1,y) == '.') {\n                    maxy = y-1;\n                    break;\n                }\n            }\n            return {miny:miny, maxy:maxy};\n        };\n        var getBotEnergizerRange = function() {\n            var miny = subrows/2;\n            var maxy;\n            var x = subcols-2;\n            var y;\n            for (y=subrows-3; y>=miny; y--) {\n                if (getTile(x,y) == '.' && getTile(x,y+1) == '.') {\n                    maxy = y;\n                    break;\n                }\n            }\n            miny = Math.max(miny,maxy-7);\n            for (y=maxy-1; y>miny; y--) {\n                if (getTile(x-1,y) == '.') {\n                    miny = y+1;\n                    break;\n                }\n            }\n            return {miny:miny, maxy:maxy};\n        };\n\n        // TODO: x->x1\n        var x1 = subcols-2;\n        var y;\n        var range;\n        if (range = getTopEnergizerRange()) {\n            y = this.getRandomInt(range.miny, range.maxy);\n            setTile(x1,y,'o');\n        }\n        if (range = getBotEnergizerRange()) {\n            y = this.getRandomInt(range.miny, range.maxy);\n            setTile(x1,y,'o');\n        }\n    \n        // erase pellets in the tunnels\n        var eraseUntilIntersection = function(x,y) {\n            var adj;\n            while (true) {\n                adj = [];\n                if (getTile(x-1,y) == '.') {\n                    adj.push({x:x-1,y:y});\n                }\n                if (getTile(x+1,y) == '.') {\n                    adj.push({x:x+1,y:y});\n                }\n                if (getTile(x,y-1) == '.') {\n                    adj.push({x:x,y:y-1});\n                }\n                if (getTile(x,y+1) == '.') {\n                    adj.push({x:x,y:y+1});\n                }\n                if (adj.length == 1) {\n                    setTile(x,y,' ');\n                    x = adj[0].x;\n                    y = adj[0].y;\n                }\n                else {\n                    break;\n                }\n            }\n        };\n        x = subcols-1;\n        for (y=0; y<subrows; y++) {\n            if (getTile(x,y) == '.') {\n                eraseUntilIntersection(x,y);\n            }\n        }\n    \n        // erase pellets on starting position\n        setTile(1,subrows-8,' ');\n    \n        // erase pellets around the ghost house\n        var i,j;\n        var y;\n        for (i=0; i<7; i++) {\n    \n            // erase pellets from bottom of the ghost house proceeding down until\n            // reaching a pellet tile that isn't surround by walls\n            // on the left and right\n            y = subrows-14;\n            setTile(i, y, ' ');\n            j = 1;\n            while (getTile(i,y+j) == '.' &&\n                    getTile(i-1,y+j) == '|' &&\n                    getTile(i+1,y+j) == '|') {\n                setTile(i,y+j,' ');\n                j++;\n            }\n    \n            // erase pellets from top of the ghost house proceeding up until\n            // reaching a pellet tile that isn't surround by walls\n            // on the left and right\n            y = subrows-20;\n            setTile(i, y, ' ');\n            j = 1;\n            while (getTile(i,y-j) == '.' &&\n                    getTile(i-1,y-j) == '|' &&\n                    getTile(i+1,y-j) == '|') {\n                setTile(i,y-j,' ');\n                j++;\n            }\n        }\n        // erase pellets on the side of the ghost house\n        for (i=0; i<7; i++) {\n    \n            // erase pellets from side of the ghost house proceeding right until\n            // reaching a pellet tile that isn't surround by walls\n            // on the top and bottom.\n            x = 6;\n            y = subrows-14-i;\n            setTile(x, y, ' ');\n            j = 1;\n            while (getTile(x+j,y) == '.' &&\n                    getTile(x+j,y-1) == '|' &&\n                    getTile(x+j,y+1) == '|') {\n                setTile(x+j,y,' ');\n                j++;\n            }\n        }\n        return tiles.join(\"\");\n    };\n    \n    mapgen = function() {\n        console.log(\"mapgen.......\");\n        this.genRandom();\n        return this.getTiles(); \n    };\n    \n}","import { observable } from 'mobx';\nimport {Game} from './Game';\nimport {MapGen} from './MapGen';\n\nexport type TileId = number;\n\nexport const EMPTY_TILE_ID: TileId = 0;\nexport const BASIC_PILL_ID: TileId = 1; \nexport const ENERGIZER_ID: TileId = 2;\n\nexport const WAY_FREE_ID: TileId = 3;\nexport const BOX_DOOR_ID: TileId = 4;\n\nexport const MAZE_WIDTH_IN_TILES = 28;\nexport const MAZE_HEIGHT_IN_TILES = 31;\n\nexport type TileMatrix = number[][];\n\nexport class Maze {\n    @observable\n    pills: TileId[][];\n    \n    @observable\n    ways: TileId[][];\n\n    combineMap:string;\n\n    constructor(game:Game){\n        console.log(\"Maze-In\");\n        this.buildGame();\n    }\n\n    buildGame = () => {\n        this.combineMap = new MapGen().mapgen();\n        this.pills = this.parsePillMatrix(this.combineMap);\n        this.ways = this.parseWayMatrix(this.combineMap);\n    }\n\n    parsePillMatrix = (data: string): TileMatrix => {\n        const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n        let dataIndex = 0;\n        for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n            tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n            for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n                const charId = data[dataIndex];\n                let tileId = 0;\n                switch(charId){\n                    case 'o':\n                        tileId = ENERGIZER_ID;\n                        break;\n                    case ' ':\n                    case '.':\n                        tileId = BASIC_PILL_ID;\n                        break;\n                }\n                tileMatrix[ty][tx] = tileId;\n                dataIndex++;\n            }\n        }\n        return tileMatrix;\n    };\n\n    parseWayMatrix = (data: string): TileMatrix => {\n        const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n        let dataIndex = 0;\n        for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n            tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n            for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n                const charId = data[dataIndex];\n                let tileId = 0;\n                switch(charId){\n                    case '|':\n                        tileId = 0;\n                        break;\n                    case '-':\n                        tileId = 4;\n                        break;\n                    case '_':\n                    case ' ':\n                    case '.':\n                    case 'o':\n                    default:\n                        tileId = 3;\n                        break;\n                }\n                tileMatrix[ty][tx] = tileId;\n                dataIndex++;\n            }\n        }\n        console.log(tileMatrix);\n        return tileMatrix;\n    };\n\n    flatTiles = () => {\n        return this.combineMap;\n    }\n\n}\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './Maze';\nimport { assert } from '../util/assert';\nimport { Vector } from './Vector';\n\nexport type Coordinate = number;\n\nexport type TileCoordinate = Coordinate;\nexport type ScreenCoordinate = Coordinate;\n\nexport interface TileCoordinates {\n    x: TileCoordinate;\n    y: TileCoordinate;\n}\n\nexport interface ScreenCoordinates {\n    x: ScreenCoordinate;\n    y: ScreenCoordinate;\n}\n\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\n\nexport interface TileRectangle {\n    tile1: TileCoordinates;\n    tile2: TileCoordinates;\n}\n\nexport const SCALE_FACTOR = 2;\nexport const SPRITE_TILE_SIZE = 8;\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\n\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\n    x: SCREEN_TILE_CENTER,\n    y: SCREEN_TILE_CENTER\n};\n\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES = MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES = MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\n\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\n    x: MAZE_WIDTH_IN_TILES,\n    y: MAZE_HEIGHT_IN_TILES\n};\n\nexport const isTxValid = (tx: TileCoordinate) => tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\nexport const isTyValid = (ty: TileCoordinate) => ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\nexport const isValidTileCoordinates = (tile: TileCoordinates) => isTxValid(tile.x) && isTyValid(tile.y);\n\nexport const assertValidTx = (tx: TileCoordinate) => {\n    assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\n};\n\nexport const assertValidTy = (ty: TileCoordinate) => {\n    assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\n};\n\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\n    assertValidTx(tile.x);\n    assertValidTy(tile.y);\n};\n\nexport const screenFromTileCoordinate = (tileCoordinate: TileCoordinate): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\n\nexport const tileFromScreenCoordinate = (screenCoordinate: ScreenCoordinate): TileCoordinate =>\n    Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\n\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\n    x: screenFromTileCoordinate(tile.x),\n    y: screenFromTileCoordinate(tile.y)\n});\n\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\n    x: tileFromScreenCoordinate(screen.x),\n    y: tileFromScreenCoordinate(screen.y)\n});\n\nexport const getPointDifferenceAsVector = (from: Coordinates, to: Coordinates): Vector => ({\n    x: to.x - from.x,\n    y: to.y - from.y\n});\n\nexport const addCoordinatesAndVector = (coordinates: Coordinates, vector: Vector): ScreenCoordinates => ({\n    x: coordinates.x + vector.x,\n    y: coordinates.y + vector.y\n});\n\nexport const rectangleContainsTile = (tileRectangle: TileRectangle, tile: TileCoordinates): boolean =>\n    tile.x >= tileRectangle.tile1.x &&\n    tile.x <= tileRectangle.tile2.x &&\n    tile.y >= tileRectangle.tile1.y &&\n    tile.y <= tileRectangle.tile2.y;\n\nexport const wrapTileToBounds = (tile: TileCoordinates, bounds: TileCoordinates): TileCoordinates => {\n    const wrappedX = (tile.x + bounds.x) % bounds.x;\n    const wrappedY = (tile.y + bounds.y) % bounds.y;\n    return { x: wrappedX, y: wrappedY };\n};\n","import React, { FC, CSSProperties } from 'react';\nimport classNames from 'classnames';\nimport { SCALE_FACTOR } from '../model/Coordinates';\nimport './Sprite.css';\n\nconst scale = `scale(${SCALE_FACTOR})`;\n\nexport const Sprite: FC<{\n    name: string;\n    x: number;\n    y: number;\n    className?: string | null;\n    style?: CSSProperties;\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\n    return (\n        <div\n            className={classNames('Sprite', 'Sprite-' + spriteName, className)}\n            style={{\n                ...style,\n                position: 'absolute',\n                left: `${x}px`,\n                top: `${y}px`,\n                transform: scale,\n                transformOrigin: 'top left'\n            }}\n        />\n    );\n};\n","import React, { FC } from 'react';\nimport { Rectangle } from '../model/Rectangle';\n\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({ rect, color }) => (\n    <div\n        style={{\n            position: 'absolute',\n            left: rect.x,\n            top: rect.y,\n            width: rect.width,\n            height: rect.height,\n            backgroundColor: color,\n            zIndex: 1000\n        }}\n    />\n);\n","import { Rectangle } from './Rectangle';\n\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\n    return (\n        rect1.x < rect2.x + rect2.width &&\n        rect1.x + rect1.width > rect2.x &&\n        rect1.y < rect2.y + rect2.height &&\n        rect1.y + rect1.height > rect2.y\n    );\n};\n","import { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const ENERGIZER_POINTS = 30;\n\nexport const eatEnergizer = action((game: Game) => {\n    game.score += ENERGIZER_POINTS;\n    game.killedGhosts = 0;\n    game.pacMan.send('ENERGIZER_EATEN');\n    for (const ghost of game.ghosts) {\n        ghost.send('ENERGIZER_EATEN');\n    }\n});\n","import { collide } from './collisionDetection';\nimport { SCALE_FACTOR, ScreenCoordinates, screenFromTile, TileCoordinates } from './Coordinates';\nimport { eatEnergizer } from './eatEnergizer';\nimport { Game } from './Game';\nimport { Ghost } from './Ghost';\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './Maze';\nimport { Rectangle } from './Rectangle';\n\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\n\nexport const getPillHitBox = (tile: TileCoordinates, pill: TileId): Rectangle => {\n    const screen = screenFromTile(tile);\n    return {\n        x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\n        y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\n        width: PILL_BOX_HIT_BOX_WIDTH,\n        height: PILL_BOX_HIT_BOX_HEIGHT\n    };\n};\n\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\n\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\n    return {\n        x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\n        y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\n        width: PAC_MAN_HIT_BOX_WIDTH,\n        height: PAC_MAN_HIT_BOX_HEIGHT\n    };\n};\n\nconst GHOST_HIT_BOX_WIDTH = 10;\nconst GHOST_HIT_BOX_HEIGHT = 10;\n\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\n    return {\n        x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\n        y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\n        width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\n        height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR\n    };\n};\n\nconst detectPacManEatingPill = (game: Game) => {\n    const pillTile = game.pacMan.tileCoordinates;\n    const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\n    if (pill === EMPTY_TILE_ID) {\n        return;\n    }\n\n    const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\n    const pacManHitBox: Rectangle = getPacManHitBox(game.pacMan.screenCoordinates);\n    if (collide(pacManHitBox, pillHitBox)) {\n        eatPillLayerObject(pillTile, game);\n    }\n};\n\nexport const BASIC_PILL_POINTS = 10;\n\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\n    const tileId = game.maze.pills[tile.y][tile.x];\n    switch (tileId) {\n        case BASIC_PILL_ID:\n            eatPill(tile, game);\n            break;\n        case ENERGIZER_ID:\n            eatEnergizer(game);\n            break;\n        default:\n            console.error('Unknown pill layer tile id', tileId);\n            break;\n    }\n\n    game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\n};\n\nconst eatPill = (tile: TileCoordinates, game: Game) => {\n    game.score += BASIC_PILL_POINTS;\n};\n\nconst detectGhostCollisions = (game: Game) => {\n    const pacManHitBox: Rectangle = getPacManHitBox(game.pacMan.screenCoordinates);\n\n    for (const ghost of game.ghosts) {\n        if (ghost.dead) {\n            continue;\n        }\n\n        const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\n        if (collide(pacManHitBox, ghostHitBox)) {\n            ghostCollidesWithPacMan(ghost);\n        }\n    }\n};\n\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\n    const game = ghost.game;\n    game.pacMan.send('COLLISION_WITH_GHOST');\n    ghost.send('COLLISION_WITH_PAC_MAN');\n};\n\nexport const detectCollisions = (game: Game) => {\n    if (game.pacMan.dead) {\n        return;\n    }\n\n    detectPacManEatingPill(game);\n    detectGhostCollisions(game);\n};\n","import { MilliSeconds } from './Types';\nimport { PacMan } from './PacMan';\n\nexport type PacManDyingPhase = number;\nexport const PacManDyingPhaseCount = 13;\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(Array(PacManDyingPhaseCount).keys());\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\nexport const TotalPacManDyingAnimationLength: MilliSeconds = PacManDyingPhaseLength * PacManDyingPhaseCount;\n\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\n    let dyingPhase: number = Math.floor(pacMan.timeSinceDeath / PacManDyingPhaseLength);\n    if (dyingPhase >= PacManDyingPhaseCount) {\n        dyingPhase = PacManDyingPhaseCount - 1;\n    }\n    return dyingPhase as PacManDyingPhase;\n};\n","import React, { FC, CSSProperties } from 'react';\nimport { Sprite } from '../../../components/Sprite';\nimport { Direction } from '../../../model/Types';\nimport { observer } from 'mobx-react-lite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { SCREEN_TILE_SIZE, SCREEN_TILE_CENTER } from '../../../model/Coordinates';\nimport { Box } from '../../../components/Box';\nimport { PacMan } from '../../../model/PacMan';\nimport { getPacManHitBox } from '../../../model/detectCollisions';\nimport { PacManDyingPhase, getPacManDyingPhase } from '../../../model/pacManDyingPhase';\n\nexport type PacManAnimationPhase = 0 | 1 | 2;\n\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\n\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\n\nexport const PacManView: FC = observer(() => {\n    const store = useStore();\n    const game = useGame();\n    const pacMan = game.pacMan;\n    const { dead, alive, screenCoordinates, direction } = pacMan;\n    const { gameViewOptions } = store.debugState;\n    const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\n    const dyingPhase = getPacManDyingPhase(pacMan);\n    return (\n        <>\n            {gameViewOptions.hitBox && (\n                <PacManHitBox x={screenCoordinates.x + SCREEN_TILE_CENTER} y={screenCoordinates.y + SCREEN_TILE_CENTER} />\n            )}\n            {alive && (\n                <PacManSprite\n                    direction={direction}\n                    pacManAnimationPhase={pacManAnimationPhase}\n                    x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n                    y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n                />\n            )}\n            {dead && (\n                <DyingPacManSprite\n                    dyingPacManAnimationPhase={dyingPhase}\n                    x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n                    y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n                />\n            )}\n        </>\n    );\n});\n\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\n    const step = Math.round(pacMan.game.timestamp / 200) % 4;\n    const phase = step === 3 ? 1 : step;\n    return phase as PacManAnimationPhase;\n};\n\nexport const PacManSprite: FC<{\n    direction: Direction;\n    pacManAnimationPhase: PacManAnimationPhase;\n    x: number;\n    y: number;\n    style?: CSSProperties;\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\n    <Sprite className=\"Sprite-pacman\" name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`} x={x} y={y} style={style} />\n);\n\nexport const DyingPacManSprite: FC<{\n    dyingPacManAnimationPhase: PacManDyingPhase;\n    x: number;\n    y: number;\n    style?: CSSProperties;\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\n    <Sprite className=\"Sprite-dying-pacman\" name={`dying-pacman-phase-${dyingPacManAnimationPhase}`} x={x} y={y} style={style} />\n);\n\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\n    const rect = getPacManHitBox({ x, y });\n    return <Box rect={rect} color=\"green\" />;\n};\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport classNames from 'classnames';\nimport styled from 'styled-components/macro';\nimport { PacManSprite } from './PacManView';\nimport { times } from 'lodash';\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\n\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\n    const game = useGame();\n    return (\n        <Layout className={classNames('ExtraLives', className)}>\n            <span>\n                {times(game.pacMan.extraLivesLeft, (n) => (\n                    <PacManSprite key={n} direction=\"LEFT\" pacManAnimationPhase={1} x={n * 20 * SCALE_FACTOR} y={0} />\n                ))}\n            </span>\n        </Layout>\n    );\n});\n\nconst Layout = styled.div`\n    display: inline-flex;\n    position: relative;\n    width: calc(1 * 40px * var(--SCALE_FACTOR));\n    height: calc(16px * var(--SCALE_FACTOR));\n`;\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\n\nexport const Message = observer<{ className?: string; text: string }>(({ className, text }) => {\n    return <MessageStyled className={className}>{text}</MessageStyled>;\n});\n\nconst MessageStyled = styled.span`\n    font-family: Joystix;\n    font-size: 24px;\n    color: yellow;\n    position: absolute;\n    left: 170px;\n    top: 332px;\n    width: 220px;\n    text-align: center;\n`;\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport './GameOver.css';\nimport { useGame } from '../../../components/StoreContext';\nimport { Message } from './Message';\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\n\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\n\nexport const GameOver: FC<{ className?: string }> = observer(({ className }) => {\n    const game = useGame();\n    const { pacMan } = game;\n    const gameOverMessageVisible = game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\n\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\n});\n","import React from 'react';\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Direction } from '../../model/Types';\n\nconst x1 = 30;\nconst y1 = 30;\nconst x2 = 70;\nconst y2 = 70;\nconst x3 = 50;\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\n\nconst DirectionToAngle = {\n    DOWN: 0,\n    LEFT: 90,\n    UP: 180,\n    RIGHT: 270\n};\n\nexport const WayPoint: React.FC<{\n    screenCoordinates: ScreenCoordinates;\n    color: string;\n    direction: Direction;\n}> = ({ screenCoordinates, color, direction }) => {\n    const angle = DirectionToAngle[direction];\n    return (\n        <SvgStyled\n            viewBox=\"0 0 100 100\"\n            height=\"6\"\n            width=\"6\"\n            style={{\n                left: `${screenCoordinates.x + 1}px`,\n                top: `${screenCoordinates.y}px`\n            }}\n        >\n            <g transform={`rotate(${angle} 50 50)`}>\n                <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\n            </g>\n        </SvgStyled>\n    );\n};\n\nconst SvgStyled = styled.svg`\n    position: absolute;\n    display: block;\n    width: ${SCREEN_TILE_SIZE}px;\n    height: ${SCREEN_TILE_SIZE}px;\n    pointer-events: none;\n`;\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\nimport { isEqual } from 'lodash';\nimport { assert } from '../util/assert';\nimport { Direction } from './Types';\nimport { MAZE_WIDTH_IN_TILES } from './Maze';\n\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\n\nexport const getDirectionFromTileToTile = (tileFrom: TileCoordinates, tileTo: TileCoordinates): Direction => {\n    assert(tileFrom, 'tileFrom');\n    assert(tileTo, 'tileTo');\n\n    if (isEqual(tileFrom, tileTo)) {\n        throw new Error('Same tile');\n    }\n\n    // Go through the tunnel?\n    if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\n        return 'RIGHT';\n    }\n    // Go through the tunnel?\n    if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\n        return 'LEFT';\n    }\n    if (tileFrom.x < tileTo.x) {\n        return 'RIGHT';\n    }\n    if (tileFrom.x > tileTo.x) {\n        return 'LEFT';\n    }\n    if (tileFrom.y < tileTo.y) {\n        return 'DOWN';\n    }\n    if (tileFrom.y > tileTo.y) {\n        return 'UP';\n    }\n    throw new Error('Same tiles');\n};\n","/* eslint-disable react/no-unescaped-entities */\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\nimport { WayPoint } from './WayPoint';\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\nimport { Direction } from '../../model/Types';\nimport { assert } from '../../util/assert';\n\nexport const WayPoints = observer<{\n    wayPoints: TileCoordinates[];\n    color: string;\n}>(({ wayPoints, color }) => (\n    <>\n        {wayPoints.map((wayPoint, index) => {\n            const screenCoordinates = screenFromTile(wayPoint);\n            const direction = getDirection(wayPoints, index);\n            return <WayPoint key={index} screenCoordinates={screenCoordinates} color={color} direction={direction} />;\n        })}\n    </>\n));\n\nconst getDirection = (wayPoints: TileCoordinates[], index: number): Direction => {\n    if (wayPoints.length <= 1) {\n        return 'DOWN';\n    }\n    const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\n    const fromTile = wayPoints[indexToUse];\n    const toTile = wayPoints[indexToUse + 1];\n    assert(toTile, `${indexToUse} ${wayPoints.length}`);\n    const direction = getDirectionFromTileToTile(fromTile, toTile);\n    return direction;\n};\n","import React, { FC } from 'react';\nimport { TileCoordinates, SCREEN_TILE_SIZE, screenFromTileCoordinate, SCREEN_TILE_CENTER } from '../../../model/Coordinates';\n\nconst SIZE = SCREEN_TILE_SIZE * 2;\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\n\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({ tile, color }) => (\n    <div\n        style={{\n            position: 'absolute',\n            left: screenFromTileCoordinate(tile.x) + OFFSET,\n            top: screenFromTileCoordinate(tile.y) + OFFSET,\n            width: SIZE,\n            height: SIZE\n        }}\n    >\n        <svg version=\"1.1\" viewBox=\"0 0 22 22\">\n            <path\n                style={{ fill: color }}\n                transform={`rotate(45 11 11) translate(-550.29-608.65)`}\n                d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\n            />\n        </svg>\n    </div>\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport { SCREEN_TILE_SIZE, SCREEN_TILE_CENTER } from '../../../model/Coordinates';\nimport { getGhostHitBox } from '../../../model/detectCollisions';\nimport { Ghost, GhostAnimationPhase, FrightenedGhostTime } from '../../../model/Ghost';\nimport { Direction } from '../../../model/Types';\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { Target } from './Target';\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\nimport { GameViewOptions } from '../../../model/GameViewOptions';\n\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\n\nexport const GhostsGameView = observer(() => {\n    const store = useStore();\n    const { ghostViewOptions, gameViewOptions } = store.debugState;\n\n    return <GhostsView ghostViewOptions={ghostViewOptions} gameViewOptions={gameViewOptions} />;\n});\n\nexport const GhostsView: FC<{\n    ghostViewOptions?: GhostViewOptions;\n    gameViewOptions?: GameViewOptions;\n}> = observer(({ ghostViewOptions = DefaultGhostViewOptions, gameViewOptions = DefaultGameViewOptions }) => {\n    const store = useGame();\n\n    return (\n        <>\n            {store.ghosts.map((ghost) => (\n                <GhostCompositeView\n                    key={ghost.ghostNumber}\n                    ghost={ghost}\n                    ghostViewOptions={ghostViewOptions}\n                    gameViewOptions={gameViewOptions}\n                />\n            ))}\n        </>\n    );\n});\n\nconst DefaultGhostViewOptions: GhostViewOptions = {\n    target: false,\n    wayPoints: false\n};\n\nconst DefaultGameViewOptions: GameViewOptions = {\n    hitBox: false\n};\n\nexport const GhostCompositeView: FC<{\n    ghost: Ghost;\n    ghostViewOptions: GhostViewOptions;\n    gameViewOptions: GameViewOptions;\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\n    const { screenCoordinates } = ghost;\n    return (\n        <>\n            {gameViewOptions.hitBox && (\n                <GhostHitBox x={screenCoordinates.x + SCREEN_TILE_CENTER} y={screenCoordinates.y + SCREEN_TILE_CENTER} color=\"green\" />\n            )}\n            <GhostView ghost={ghost} />\n            {ghostViewOptions.wayPoints && <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />}\n            {ghostViewOptions.target && <Target tile={ghost.targetTile} color={ghost.colorCode} />}\n        </>\n    );\n});\n\nexport const GhostView: FC<{\n    ghost: Ghost;\n}> = observer(({ ghost }) => {\n    const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\n    // TODO\n    switch (ghost.state) {\n        case 'frightened':\n            return (\n                <FrightenedGhostSprite\n                    frightenedGhostTime={ghost.frightenedGhostTime}\n                    ghostAnimationPhase={animationPhase}\n                    x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n                    y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n                />\n            );\n        case 'dead':\n            return (\n                <DeadGhostSprite\n                    direction={direction}\n                    x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n                    y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n                />\n            );\n        default:\n            return (\n                <GhostSprite\n                    direction={direction}\n                    ghostAnimationPhase={animationPhase}\n                    x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n                    y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n                    ghostNumber={ghostNumber}\n                />\n            );\n    }\n});\n\ntype GhostSpriteProps = {\n    direction: Direction;\n    ghostAnimationPhase: GhostAnimationPhase;\n    x: number;\n    y: number;\n    ghostNumber: number;\n    style?: { [key: string]: any };\n};\n\nexport const GhostSprite: FC<GhostSpriteProps> = ({ direction, ghostAnimationPhase: phase, x, y, ghostNumber, style }) => (\n    <Sprite className=\"Sprite-ghost\" name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`} x={x} y={y} style={style} />\n);\n\ntype DeadGhostSpriteProps = {\n    direction: Direction;\n    x: number;\n    y: number;\n    style?: { [key: string]: any };\n};\n\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({ direction, x, y, style }) => (\n    <Sprite className=\"Sprite-ghost\" name={`dead-ghost-direction-${direction}`} x={x} y={y} style={style} />\n);\n\ntype FrightenedGhostSpriteProps = {\n    x: number;\n    y: number;\n    ghostAnimationPhase: GhostAnimationPhase;\n    frightenedGhostTime: FrightenedGhostTime;\n    style?: { [key: string]: any };\n};\n\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({ x, y, ghostAnimationPhase, frightenedGhostTime, style }) => (\n    <Sprite\n        className=\"Sprite-ghost\"\n        name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\n        x={x}\n        y={y}\n        style={style}\n    />\n);\n\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({ x, y, color }) => {\n    const rect = getGhostHitBox({ x, y });\n    return <Box rect={rect} color={color} />;\n};\n","\n// direction enums (in clockwise order)\nconst DIR_UP = 0;\nconst DIR_RIGHT = 1;\nconst DIR_DOWN = 2;\nconst DIR_LEFT = 3;\n\n// get direction enum from a direction vector\nconst getEnumFromDir = function(dir) {\n    if (dir.x==-1) return DIR_LEFT;\n    if (dir.x==1) return DIR_RIGHT;\n    if (dir.y==-1) return DIR_UP;\n    if (dir.y==1) return DIR_DOWN;\n};\n\n// set direction vector from a direction enum\nconst setDirFromEnum = function(dir,dirEnum) {\n    if (dirEnum == DIR_UP)         { dir.x = 0; dir.y =-1; }\n    else if (dirEnum == DIR_RIGHT)  { dir.x =1; dir.y = 0; }\n    else if (dirEnum == DIR_DOWN)  { dir.x = 0; dir.y = 1; }\n    else if (dirEnum == DIR_LEFT) { dir.x = -1; dir.y = 0; }\n};\n\n// size of a square tile in pixels\nconst tileSize = 16;\n\nclass Point {\n\tpublic x: number;\n\tpublic y: number;\n}\n\nexport class PacmanMap {\n\n    numCols = 0;\n    numRows = 0;\n    numTiles = 0;\n    widthPixels = 0;\n    heightPixels = 0;\n    tiles = \"\"; \n    wallStrokeColor = '#0000FF';\n    // constructor\n    constructor(numCols, numRows, tiles) {\n\n        // sizes\n        this.numCols = numCols;\n        this.numRows = numRows;\n        this.numTiles = numCols*numRows;\n        this.widthPixels = numCols*tileSize;\n        this.heightPixels = numRows*tileSize;\n\n        // ascii map\n        this.tiles = tiles;\n\n        this.resetCurrent();\n        this.parseWalls();\n    };\n\n    // reset current tiles\n    resetCurrent = function() {\n        this.currentTiles = this.tiles.split(\"\"); // create a mutable list copy of an immutable string\n    };\n\n    // This is a procedural way to generate original-looking maps from a simple ascii tile\n    // map without a spritesheet.\n    parseWalls = function() {\n\n        var that = this;\n\n        // creates a list of drawable canvas paths to render the map walls\n        this.paths = [];\n\n        // a map of wall tiles that already belong to a built path\n        var visited = {};\n\n        // we extend the x range to suggest the continuation of the tunnels\n        var toIndex = function(x,y) {\n            if (x>=-2 && x<that.numCols+2 && y>=0 && y<that.numRows)\n                return (x+2)+y*(that.numCols+4);\n        };\n\n        // a map of which wall tiles that are not completely surrounded by other wall tiles\n        var edges = {};\n        var i=0,x,y;\n        for (y=0;y<this.numRows;y++) {\n            for (x=-2;x<this.numCols+2;x++,i++) {\n                if (this.getTile(x,y) == '|' &&\n                    (this.getTile(x-1,y) != '|' ||\n                    this.getTile(x+1,y) != '|' ||\n                    this.getTile(x,y-1) != '|' ||\n                    this.getTile(x,y+1) != '|' ||\n                    this.getTile(x-1,y-1) != '|' ||\n                    this.getTile(x-1,y+1) != '|' ||\n                    this.getTile(x+1,y-1) != '|' ||\n                    this.getTile(x+1,y+1) != '|')) {\n                    edges[i] = true;\n                }\n            }\n        }\n\n        // walks along edge wall tiles starting at the given index to build a canvas path\n        const makePath = (tx,ty) => {\n\n            // get initial direction\n            let dir:Point = new Point();\n            var dirEnum;\n            if (toIndex(tx+1,ty) in edges) {\n                dirEnum = DIR_RIGHT;\n            } else if (toIndex(tx, ty+1) in edges) {\n                dirEnum = DIR_DOWN;\n            } else {\n                throw \"tile shouldn't be 1x1 at \"+tx+\",\"+ty;\n            }\n            setDirFromEnum(dir,dirEnum);\n\n            // increment to next tile\n            tx += dir.x;\n            ty += dir.y;\n\n            // backup initial location and direction\n            var init_tx = tx;\n            var init_ty = ty;\n            var init_dirEnum = dirEnum;\n\n            var path = [];\n            var pad; // (persists for each call to getStartPoint)\n            var point;\n            var lastPoint;\n\n            var turn,turnAround;\n\n            /*\n\n            We employ the 'right-hand rule' by keeping our right hand in contact\n            with the wall to outline an individual wall piece.\n\n            Since we parse the tiles in row major order, we will always start\n            walking along the wall at the leftmost tile of its topmost row.  We\n            then proceed walking to the right.  \n\n            When facing the direction of the walk at each tile, the outline will\n            hug the left side of the tile unless there is a walkable tile to the\n            left.  In that case, there will be a padding distance applied.\n            \n            */\n            var getStartPoint = function(tx,ty,dirEnum) {\n                let dir:Point = new Point();\n                setDirFromEnum(dir, dirEnum);\n\n                if (!(toIndex(tx+dir.y,ty-dir.x) in edges))\n                    pad = that.isFloorTile(tx+dir.y,ty-dir.x) ? 5 : 0;\n                var px = -tileSize/2+pad;\n                var py = tileSize/2;\n                var a = dirEnum*Math.PI/2;\n                var c = Math.cos(a);\n                var s = Math.sin(a);\n                return {\n                    // the first expression is the rotated point centered at origin\n                    // the second expression is to translate it to the tile\n                    x:(px*c - py*s) + (tx+0.5)*tileSize,\n                    y:(px*s + py*c) + (ty+0.5)*tileSize,\n                };\n            };\n            while (true) {\n                \n                visited[toIndex(tx,ty)] = true;\n\n                // determine start point\n                point = getStartPoint(tx,ty,dirEnum);\n\n                if (turn) {\n                    // if we're turning into this tile, create a control point for the curve\n                    //\n                    // >---+  <- control point\n                    //     |\n                    //     V\n                    lastPoint = path[path.length-1];\n                    if (dir.x == 0) {\n                        point.cx = point.x;\n                        point.cy = lastPoint.y;\n                    }\n                    else {\n                        point.cx = lastPoint.x;\n                        point.cy = point.y;\n                    }\n                }\n\n                // update direction\n                turn = false;\n                turnAround = false;\n                if (toIndex(tx+dir.y, ty-dir.x) in edges) { // turn left\n                    dirEnum = (dirEnum+3)%4;\n                    turn = true;\n                }\n                else if (toIndex(tx+dir.x, ty+dir.y) in edges) { // continue straight\n                }\n                else if (toIndex(tx-dir.y, ty+dir.x) in edges) { // turn right\n                    dirEnum = (dirEnum+1)%4;\n                    turn = true;\n                }\n                else { // turn around\n                    dirEnum = (dirEnum+2)%4;\n                    turnAround = true;\n                }\n                setDirFromEnum(dir,dirEnum);\n\n                // commit path point\n                path.push(point);\n\n                // special case for turning around (have to connect more dots manually)\n                if (turnAround) {\n                    path.push(getStartPoint(tx-dir.x, ty-dir.y, (dirEnum+2)%4));\n                    path.push(getStartPoint(tx, ty, dirEnum));\n                }\n\n                // advance to the next wall\n                tx += dir.x;\n                ty += dir.y;\n\n                // exit at full cycle\n                if (tx==init_tx && ty==init_ty && dirEnum == init_dirEnum) {\n                    that.paths.push(path);\n                    break;\n                }\n            }\n        };\n\n        // iterate through all edges, making a new path after hitting an unvisited wall edge\n        i=0;\n        for (y=0;y<this.numRows;y++)\n            for (x=-2;x<this.numCols+2;x++,i++)\n                if (i in edges && !(i in visited)) {\n                    visited[i] = true;\n                    makePath(x,y);\n                }\n    };\n\n    posToIndex = function(x,y) {\n        if (x>=0 && x<this.numCols && y>=0 && y<this.numRows) \n            return x+y*this.numCols;\n    };\n    // retrieves tile character at given coordinate\n    // extended to include offscreen tunnel space\n    getTile = function(x,y) {\n        if (x>=0 && x<this.numCols && y>=0 && y<this.numRows) \n            return this.currentTiles[this.posToIndex(x,y)];\n\n        // extend walls and paths outward for entrances and exits\n        if ((x==-1           && this.getTile(x+1,y)=='|' && (this.isFloorTile(x+1,y+1)||this.isFloorTile(x+1,y-1))) ||\n            (x==this.numCols && this.getTile(x-1,y)=='|' && (this.isFloorTile(x-1,y+1)||this.isFloorTile(x-1,y-1))))\n            return '|';\n        if ((x==-1           && this.isFloorTile(x+1,y)) ||\n            (x==this.numCols && this.isFloorTile(x-1,y)))\n            return ' ';\n    };\n\n    // determines if the given character is a walkable floor tile\n    isFloorTileChar = function(tile) {\n        return tile==' ' || tile=='.' || tile=='o';\n    };\n\n    // determines if the given tile coordinate has a walkable floor tile\n    isFloorTile = function(x,y) {\n        return this.isFloorTileChar(this.getTile(x,y));\n    };\n\n    // function to draw the map as a tile map\n    draw = function(ctx) {\n\n        ctx.beginPath();\n        ctx.rect(0,0,this.widthPixels, this.heightPixels);\n        ctx.clip();\n\n        // set colors\n        // ctx.fillStyle = print?\"#333\":this.wallFillColor;\n        ctx.strokeStyle = this.wallStrokeColor;\n        ctx.lineWidth = 2;\n        var i,j;\n\n        for (i=0; i<this.paths.length; i++) {\n            console.log(\"this.paths.length\", this.paths.length);\n            var path = this.paths[i];\n            ctx.beginPath();\n            ctx.moveTo(path[0].x, path[0].y);\n            for (j=1; j<path.length; j++) {\n                if (path[j].cx != undefined)\n                    ctx.quadraticCurveTo(path[j].cx, path[j].cy, path[j].x, path[j].y);\n                else\n                    ctx.lineTo(path[j].x, path[j].y);\n            }\n            ctx.quadraticCurveTo(path[j-1].x, path[0].y, path[0].x, path[0].y);\n            //ctx.fill();\n            ctx.stroke();\n        }\n    };\n\n    // function to draw the map using simple representation of the paths as straight lines\n    drawPath = function(ctx,left,top) {\n        var print = true;\n\n        // save state\n        ctx.save();\n        ctx.translate(0.5,0.5); // pixel perfect lines?\n\n        // translate to the position of the map\n        ctx.translate(left,top);\n\n        // clip the drawing surface\n        ctx.beginPath();\n        ctx.rect(0,0,this.widthPixels, this.heightPixels);\n        ctx.clip();\n\n        var x,y;\n        var i,j;\n        var tile;\n\n        // draw pellets for each path tile\n        ctx.lineWidth = 2.0;\n        ctx.strokeStyle=\"rgba(0,0,0,0.8)\";\n        ctx.beginPath();\n        for (y=0; y<this.numRows-1; y++) {\n            for (x=0; x<this.numCols-1; x++) {\n                if (this.isFloorTile(x,y)) {\n                    if (this.isFloorTile(x+1,y)) {\n                        ctx.moveTo(x*tileSize,y*tileSize);\n                        ctx.lineTo((x+1)*tileSize,y*tileSize);\n                    }\n                    if (this.isFloorTile(x,y+1)) {\n                        ctx.moveTo(x*tileSize,y*tileSize);\n                        ctx.lineTo(x*tileSize,(y+1)*tileSize);\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n\n        // draw grid\n        ctx.lineWidth = 1.0;\n        ctx.strokeStyle=print?\"rgba(0,0,0,0.3)\":\"rgba(255,255,255,0.3)\";\n        ctx.beginPath();\n        for (y=0; y<this.numRows; y++) {\n            ctx.moveTo(0,y*tileSize);\n            ctx.lineTo(this.widthPixels-tileSize,y*tileSize);\n        }\n        for (x=0; x<this.numCols; x++) {\n            ctx.moveTo(x*tileSize,0);\n            ctx.lineTo(x*tileSize,this.heightPixels-tileSize);\n        }\n        ctx.stroke();\n\n        // draw title\n        if (this.name) {\n            ctx.fillStyle = print?\"#000\":\"#fff\";\n            ctx.font = \"20px sans-serif\";\n            ctx.textBaseline = \"top\";\n            ctx.fillText(this.name, 0,tileSize/2);\n        }\n\n        ctx.restore();\n\n    };\n\n};","import React, { useRef, useEffect } from 'react'\nimport {PacmanMap} from './Map';\n\nconst MazeCanvas = props => {\n  \n  const canvasRef = useRef(null)\n  \n  useEffect(() => {\n    \n    console.log(\"props.tiles\", props.tiles);\n    const canvas = canvasRef.current\n    const context = canvas.getContext('2d')\n    context.canvas.width = props.style.width;\n    context.canvas.height = props.style.height;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    const pMap = new PacmanMap(28,31, props.tiles);\n    pMap.draw(context);\n    \n  }, [])\n  \n  return <canvas ref={canvasRef} {...props}/>\n}\n\nexport default MazeCanvas;","import { useStore } from 'games/pacman-game/components/StoreContext';\nimport React, { FC } from 'react';\nimport MazeCanvas from './MazeCanvas';\n\n\n\nexport const MazeView: FC = () => {\n    const store = useStore();\n    const tiles = store.game.maze.flatTiles();\n    const waysMatrix = store.game.maze.ways;\n    const height = waysMatrix.length*16;\n    const width = waysMatrix[0].length*16;\n    return (<MazeCanvas tiles={tiles} style={{width:width, height:height, backgroundColor:'#000'}} />);\n}\n","import { observer } from 'mobx-react-lite';\nimport React, { FC, memo } from 'react';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport {\n    addCoordinatesAndVector,\n    ScreenCoordinates,\n    screenFromTile,\n    SCREEN_TILE_CENTER_VECTOR,\n    TileCoordinates\n} from '../../../model/Coordinates';\nimport { getPillHitBox } from '../../../model/detectCollisions';\nimport { BASIC_PILL_ID, ENERGIZER_ID, MAZE_HEIGHT_IN_TILES, MAZE_WIDTH_IN_TILES, EMPTY_TILE_ID } from '../../../model/Maze';\nimport { useGame } from '../../../components/StoreContext';\n\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n    <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\n);\n\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n    <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\n);\n\nexport const BasicPillHitBox: FC = () => {\n    const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\n    return <Box rect={rect} color=\"blue\" />;\n};\n\nconst PillView = observer<{ tile: TileCoordinates }>(({ tile }: { tile: TileCoordinates }) => {\n    const game = useGame();\n    const { x, y } = tile;\n    const tileId = game.maze.pills[y][x];\n    if (tileId === BASIC_PILL_ID) {\n        return <BasicPillView position={addCoordinatesAndVector(screenFromTile(tile), SCREEN_TILE_CENTER_VECTOR)} />;\n    }\n    if (tileId === ENERGIZER_ID) {\n        return <EnergizerView position={addCoordinatesAndVector(screenFromTile(tile), SCREEN_TILE_CENTER_VECTOR)} />;\n    }\n    return null;\n});\n\n// Performance tricks used here:\n// Make each PillView an observer, so that we don't have to rerender PillsView.\n// Make PillsView a React.memo to prevent any rerenders.\n// Also: Create PillView only for those coordinates where there is a pill on first render.\nexport const PillsView: FC = memo(() => {\n    const game = useGame();\n\n    return (\n        <>\n            {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\n                Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\n                    const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\n                    return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\n                })\n            )}\n        </>\n    );\n});\n\nPillsView.displayName = 'displayName';\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport './Score.css';\nimport classNames from 'classnames';\n\nexport const Score = observer<{ className?: string }>(({ className }) => {\n    const store = useGame();\n    return (\n        <div className={classNames('Score', className)}>\n            <span>Score</span>\n            <span>{store.score}</span>\n        </div>\n    );\n});\n","import styled from 'styled-components/macro';\nconst DEFAULT_SIZE = '8px';\n\nconst SIZE_MAPPING: { [key: string]: string } = {\n    small: '8px',\n    medium: '16px',\n    large: '24px'\n};\n\ntype Size = 'small' | 'middle' | 'large' | string;\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\n\nexport const HSpace = styled.div<{ size?: Size }>`\n    width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n\nexport const VSpace = styled.div<{ size?: Size }>`\n    height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n","import { assert } from '../util/assert';\n\nexport type PixelsPerFrame = number;\n\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\n\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\n\nexport type MilliSeconds = number;\n\nexport const assertValidDirection = (direction: Direction) => {\n    assert(Directions.includes(direction), `Bad direction ${direction}`);\n};\n","export interface Vector {\n    x: number;\n    y: number;\n}\n\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector => multiplyVector(-1, vector);\n\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\n    x: factor * vector.x,\n    y: factor * vector.y\n});\n\nexport const divideVector = (vector: Vector, divisor: number): Vector => multiplyVector(1 / divisor, vector);\n","import { Direction, assertValidDirection } from './Types';\nimport {\n    assertValidTileCoordinates,\n    ScreenCoordinates,\n    TileCoordinates,\n    SCREEN_TILE_SIZE,\n    rectangleContainsTile,\n    TileRectangle,\n    wrapTileToBounds,\n    MAZE_DIMENSIONS_IN_TILES,\n    addCoordinatesAndVector\n} from './Coordinates';\nimport { WAY_FREE_ID, BOX_DOOR_ID } from './Maze';\nimport { Vector, multiplyVector } from './Vector';\n\nconst BOX_TILE_COORDINATES: TileRectangle = {\n    tile1: { x: 10, y: 12 },\n    tile2: { x: 17, y: 16 }\n};\n\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\n    tile1: { x: 12, y: 14 },\n    tile2: { x: 15, y: 14 }\n};\n\nexport const isWayFreeAt = (tile: TileCoordinates, waysMatrix): boolean => {\n    assertValidTileCoordinates(tile);\n    return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\n};\n\nexport const isBoxDoorAt = (tile: TileCoordinates, waysMatrix): boolean => {\n    assertValidTileCoordinates(tile);\n    return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\n};\n\nexport const isTileInBox = (tile: TileCoordinates): boolean => rectangleContainsTile(BOX_TILE_COORDINATES, tile);\n\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean => rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\n\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\n    return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\n};\n\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\n    RIGHT: { x: 1, y: 0 },\n    LEFT: { x: -1, y: 0 },\n    UP: { x: 0, y: -1 },\n    DOWN: { x: 0, y: 1 }\n};\n\nexport const directionToVector = (direction: Direction, distance = 1): Vector => multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\n\nexport const moveFromTile = (tile: TileCoordinates, direction: Direction, steps = 1) => {\n    const step = DIRECTION_TO_VECTOR[direction];\n    const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\n    return newTile;\n};\n\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\n    RIGHT: 'LEFT',\n    LEFT: 'RIGHT',\n    UP: 'DOWN',\n    DOWN: 'UP'\n};\n\nexport const isOppositeDirection = (direction1: Direction, direction2: Direction) => {\n    return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\n};\n\nexport const isWayFreeInDirection = (tile: TileCoordinates, direction: Direction, waysMatrix, stepSize = 1): boolean => {\n    const nextTile = getNextTile(tile, direction, stepSize);\n    return isWayFreeAt(nextTile, waysMatrix);\n};\n\nexport const getNextTile = (tile: TileCoordinates, direction: Direction, stepSize = 1): TileCoordinates => {\n    assertValidDirection(direction);\n    const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\n    const scaledVector = multiplyVector(stepSize, vector);\n    const movedTile = addCoordinatesAndVector(tile, scaledVector);\n    const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\n    return nextTile;\n};\n\nconst DIRECTION_TO_TILE_VECTOR = {\n    RIGHT: { x: 1, y: 0 },\n    LEFT: { x: -1, y: 0 },\n    UP: { x: 0, y: -1 },\n    DOWN: { x: 0, y: 1 }\n};\n","import { TileCoordinates } from './Coordinates';\n\nexport const getTileDistance = (neighbourTile: TileCoordinates, targetTile: TileCoordinates) => {\n    const dx = Math.abs(neighbourTile.x - targetTile.x);\n    const dy = Math.abs(neighbourTile.y - targetTile.y);\n    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import { TileCoordinates, getPointDifferenceAsVector, addCoordinatesAndVector } from './Coordinates';\nimport { Ghost } from './Ghost';\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { Directions, Direction } from './Types';\nimport { rotateVectorBy180Degrees } from './Vector';\nimport { assert } from '../util/assert';\n\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\n    x: 13,\n    y: 11\n};\n\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\n    x: 14,\n    y: 14\n};\n\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\n\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\n    switch (ghost.state) {\n        case 'scatter':\n            return chooseInScatterMode(ghost);\n        case 'chase':\n            return choseInChaseMode(ghost);\n        case 'frightened':\n            return chooseInFrightenedMode(ghost);\n        case 'dead':\n            return chooseInDeadMode(ghost);\n        default:\n            throw new Error(`Bad state ${ghost.state}`);\n    }\n};\n\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\n    if (ghost.isInsideBoxWalls) {\n        return TILE_FOR_LEAVING_THE_BOX;\n    }\n    switch (ghost.ghostNumber) {\n        case 0:\n            return SCATTER_TILE_FOR_GHOST_0;\n        case 1:\n            return { x: 1, y: 1 };\n        case 2:\n            return { x: 26, y: 29 };\n        case 3:\n            return { x: 1, y: 29 };\n        default:\n            throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n    }\n};\n\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\n    const pacMan = ghost.game.pacMan;\n    return pacMan.tileCoordinates;\n};\n\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\n    const pacMan = ghost.game.pacMan;\n    const fourTilesAhead = moveFromTile(pacMan.tileCoordinates, pacMan.direction, 4);\n    return pacMan.direction === 'UP' ? moveFromTile(fourTilesAhead, 'LEFT', 4) : fourTilesAhead;\n};\n\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\n    const intermediateTile = chooseGhost2IntermediateTile(ghost);\n    const blinky = ghost.game.ghosts[0];\n    const vectorToBlinky = getPointDifferenceAsVector(intermediateTile, blinky.tileCoordinates);\n    const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\n    const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\n\n    return newTile;\n};\n\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\n    const pacMan = ghost.game.pacMan;\n    const twoTilesAhead = moveFromTile(pacMan.tileCoordinates, pacMan.direction, 2);\n    return pacMan.direction === 'UP' ? moveFromTile(twoTilesAhead, 'LEFT', 2) : twoTilesAhead;\n};\n\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\n    const pacMan = ghost.game.pacMan;\n    const distance = getTileDistance(ghost.tileCoordinates, pacMan.tileCoordinates);\n\n    return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\n};\n\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\n    if (ghost.isInsideBoxWalls) {\n        return TILE_FOR_LEAVING_THE_BOX;\n    }\n    switch (ghost.ghostNumber) {\n        case 0:\n            return chooseForGhost0InChaseState(ghost);\n        case 1:\n            return chooseForGhost1InChaseState(ghost);\n        case 2:\n            return chooseForGhost2InChaseState(ghost);\n        case 3:\n            return chooseForGhost3InChaseState(ghost);\n        default:\n            throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n    }\n};\n\nconst getRandomInt = (max: number) => Math.floor(Math.random() * Math.floor(max));\n\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\n    // Choose a random neighbour tile that is not backward and not into a wall.\n\n    return chooseSomeRandomMovement(ghost);\n};\n\n/**\n * Choose a random neighbour tile that is not backward and not into a wall.\n */\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\n    const ways = ghost.game.maze.ways;\n    const candidateDirections: Direction[] = Directions.filter(\n        (direction) => direction !== ghost.direction && isWayFreeInDirection(ghost.tileCoordinates, direction, ways)\n    );\n    assert(candidateDirections.length > 0);\n    const newDirection = candidateDirections[getRandomInt(candidateDirections.length)];\n    assert(newDirection);\n    const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\n\n    return randomNeighourTile;\n};\n\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\n    // if (ghost.deadWaitingTimeInBoxLeft < 0) {\n    //   return chooseSomeRandomMovement(ghost);\n    // }\n    return TILE_FOR_RETURNING_TO_BOX;\n};\n","import { minBy } from 'lodash';\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\nimport { Direction, Directions } from './Types';\nimport { getNextTile, isOppositeDirection, isWayFreeAt, isBoxDoorAt } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { toJS } from 'mobx';\nimport { assert } from '../util/assert';\n\ninterface CandidateTile {\n    tile: TileCoordinates;\n    distanceToTarget: number;\n}\n\nexport const chooseNextTile = ({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n    waysMatrix\n}: {\n    currentTile: TileCoordinates;\n    currentDirection: Direction;\n    targetTile: TileCoordinates;\n    boxDoorIsOpen: boolean;\n    waysMatrix:number[][]\n}): TileCoordinates => {\n    assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\n    const bestNextTile = chooseBestNextTile({\n        currentTile,\n        currentDirection,\n        targetTile,\n        boxDoorIsOpen,\n        waysMatrix\n    });\n\n    if (bestNextTile) {\n        assert(isValidTileCoordinates(bestNextTile));\n        return bestNextTile;\n    }\n\n    const anyNextTile = chooseAnyNextTile({\n        currentTile,\n        currentDirection,\n        boxDoorIsOpen,\n        waysMatrix\n    });\n    if (anyNextTile) {\n        assert(isValidTileCoordinates(anyNextTile));\n        return anyNextTile;\n    }\n\n    console.error('currentTile', currentTile);\n    console.error('currentDirection', currentDirection);\n    console.error('boxDoorIsOpen', boxDoorIsOpen);\n    console.error('targetTile', toJS(targetTile));\n\n    throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\n};\n\nconst chooseBestNextTile = ({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n    waysMatrix\n}: {\n    currentTile: TileCoordinates;\n    currentDirection: Direction;\n    targetTile: TileCoordinates;\n    boxDoorIsOpen: boolean;\n    waysMatrix: number[][]\n}): TileCoordinates | null => {\n    const candidates = [] as CandidateTile[];\n    for (const direction of Directions) {\n        // Prevent the ghost from going backwards\n        if (isOppositeDirection(direction, currentDirection)) {\n            continue;\n        }\n        const neighbourTile = getNextTile(currentTile, direction);\n\n        if (!possibleNextTile(neighbourTile, boxDoorIsOpen, waysMatrix)) {\n            continue;\n        }\n\n        const distanceToTarget = getTileDistance(neighbourTile, targetTile);\n        candidates.push({ tile: neighbourTile, distanceToTarget });\n    }\n\n    const bestCandidate = minBy(candidates, 'distanceToTarget');\n    if (bestCandidate) {\n        return bestCandidate.tile;\n    } else {\n        return null;\n    }\n};\n\nconst chooseAnyNextTile = ({\n    currentTile,\n    currentDirection,\n    boxDoorIsOpen,\n    waysMatrix\n}: {\n    currentTile: TileCoordinates;\n    currentDirection: Direction;\n    boxDoorIsOpen: boolean;\n    waysMatrix: number[][];\n}): TileCoordinates | null => {\n    // Prioritize the current direction\n    const neighbourTileInCurrentDirection = getNextTile(currentTile, currentDirection);\n\n    if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen, waysMatrix)) {\n        return neighbourTileInCurrentDirection;\n    }\n\n    // Choose any possible next tile\n    for (const direction of Directions) {\n        const neighbourTile = getNextTile(currentTile, direction);\n        if (possibleNextTile(neighbourTile, boxDoorIsOpen, waysMatrix)) {\n            return neighbourTile;\n        }\n    }\n\n    return null;\n};\n\nconst possibleNextTile = (tileCoordinates: TileCoordinates, boxDoorIsOpen: boolean, waysMatrix): boolean => {\n    return isValidTileCoordinates(tileCoordinates) && isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen, waysMatrix);\n};\n\nconst isWayFreeForGhostAt = (tileCoordinates: TileCoordinates, boxDoorIsOpen: boolean, waysMatrix): boolean =>\n    isWayFreeAt(tileCoordinates, waysMatrix) || (boxDoorIsOpen && isBoxDoorAt(tileCoordinates, waysMatrix));\n","import { action } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { MilliSeconds } from './Types';\nimport { StateValue } from 'xstate';\n\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\n\nexport const updateGhostStatePhaseTime = action('updateGhostStatePhaseTime', (ghost: Ghost) => {\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\n});\n\nexport const updateGhostStatePhase = action('updateGhostStatePhase', (ghost: Ghost) => {\n    if (!ghost.atTileCenter) {\n        return;\n    }\n\n    if (ghost.statePhaseTimer.isTimedOut) {\n        ghost.send('PHASE_END');\n        ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\n        ghost.statePhaseTimer.restart();\n    }\n});\n\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\n    switch (state) {\n        case 'chase':\n            return CHASE_PHASE_LENGTH;\n        case 'scatter':\n            return SCATTER_PHASE_LENGTH;\n        default:\n            // Never ends\n            return 9999999999;\n    }\n};\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\nimport { chooseNextTile } from './chooseNextTile';\nimport {\n    TileCoordinates,\n    MAZE_WIDTH_IN_SCREEN_COORDINATES,\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES,\n    assertValidTileCoordinates\n} from './Coordinates';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\nimport { Ghost } from './Ghost';\nimport { Direction } from './Types';\nimport { directionToVector } from './Ways';\nimport { updateGhostStatePhaseTime, updateGhostStatePhase } from './updateGhostStatePhase';\nimport { Vector } from './Vector';\nimport { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const updateGhosts = (game: Game) => {\n    for (const ghost of game.ghosts) {\n        updateGhost({ ghost });\n    }\n};\n\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\n    if (ghost.ghostPaused) {\n        return;\n    }\n\n    updateGhostStatePhaseTime(ghost);\n    updateDeadWaitingTimeInBoxLeft(ghost);\n\n    updateGhostStatePhase(ghost);\n\n    routeAndMoveGhost(ghost);\n};\n\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\n    if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\n        ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\n    }\n};\n\nexport const routeAndMoveGhost = (ghost: Ghost) => {\n    if (ghost.game.pacMan.dead) {\n        return;\n    }\n\n    if (ghost.atTileCenter) {\n        reRouteGhost(ghost);\n    }\n\n    moveGhost(ghost);\n};\n\nconst reRouteGhost = (ghost: Ghost) => {\n    ghost.targetTile = chooseNewTargetTile(ghost);\n    updateDirection(ghost);\n    updateSpeed(ghost);\n};\n\nconst updateDirection = (ghost: Ghost) => {\n    const newDirection = getNewDirection(ghost);\n    ghost.direction = newDirection;\n};\n\nconst updateSpeed = (ghost: Ghost) => {\n    const newSpeedFactor = getNewSpeedFactor(ghost);\n    ghost.speedFactor = newSpeedFactor;\n};\n\nexport const getNewDirection = (ghost: Ghost): Direction => {\n    const currentTile = ghost.tileCoordinates;\n    const currentDirection = ghost.direction;\n    const targetTile = ghost.targetTile;\n    const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\n    const waysMatrix = ghost.game.maze.ways;\n    const nextTile: TileCoordinates = chooseNextTile({\n        currentTile,\n        currentDirection,\n        targetTile,\n        boxDoorIsOpen,\n        waysMatrix\n    });\n\n    return getDirectionFromTileToTile(currentTile, nextTile);\n};\n\nconst moveGhost = (ghost: Ghost) => {\n    const vector: Vector = getGhostMovementVector(ghost);\n    moveGhostBy(ghost, vector);\n};\n\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\n    ghost.screenCoordinates.x =\n        (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) % MAZE_WIDTH_IN_SCREEN_COORDINATES;\n    ghost.screenCoordinates.y =\n        (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) % MAZE_HEIGHT_IN_SCREEN_COORDINATES;\n\n    assertValidTileCoordinates(ghost.tileCoordinates);\n});\n\nconst isInTunnel = (tile: TileCoordinates) => tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\n\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\n    const speed = ghost.game.speed * ghost.speedFactor;\n    const velocity = directionToVector(ghost.direction, speed);\n    return velocity;\n};\n\nexport const SPEED_FACTOR_HIGH = 2;\nexport const SPEED_FACTOR_NORMAL = 1;\nexport const SPEED_FACTOR_SLOW = 0.5;\n\nconst getNewSpeedFactor = (ghost: Ghost): number => {\n    if (ghost.dead) {\n        return SPEED_FACTOR_HIGH;\n    }\n    if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\n        return SPEED_FACTOR_SLOW;\n    }\n    return SPEED_FACTOR_NORMAL;\n};\n","import { action } from 'mobx';\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { Vector } from './Vector';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\n    pacMan.screenCoordinates.x =\n        (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) % MAZE_WIDTH_IN_SCREEN_COORDINATES;\n    pacMan.screenCoordinates.y += vector.y;\n});\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\nimport { Game } from './Game';\nimport { movePacManBy } from './movePacManBy';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { directionToVector as directionAsVector, isTileCenter, isWayFreeInDirection } from './Ways';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const updatePacMan = (game: Game): void => {\n    const pacMan = game.pacMan;\n    if (pacMan.alive) {\n        updateLivingPacMan(pacMan);\n    } else {\n        updateDeadPacMan(pacMan);\n    }\n};\n\nconst updateLivingPacMan = (pacMan: PacMan) => {\n    if (isTileCenter(pacMan.screenCoordinates)) {\n        const tile = tileFromScreen(pacMan.screenCoordinates);\n        const waysMatrix = pacMan.game.maze.ways;\n\n        // Change direction if necessary\n        if (pacMan.direction !== pacMan.nextDirection && isWayFreeInDirection(tile, pacMan.nextDirection, waysMatrix)) {\n            pacMan.direction = pacMan.nextDirection;\n        }\n\n        // Move\n        if (isWayFreeInDirection(tile, pacMan.direction, waysMatrix)) {\n            movePacMan(pacMan);\n        }\n    } else {\n        movePacMan(pacMan);\n    }\n};\n\nconst movePacMan = (pacMan: PacMan): void => {\n    const speed = pacMan.game.speed;\n    const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\n    movePacManBy(pacMan, delta);\n};\n\nconst updateDeadPacMan = (pacMan: PacMan) => {\n    if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\n        revivePacMan(pacMan);\n    }\n    return;\n};\n\nconst revivePacMan = (pacMan: PacMan) => {\n    if (pacMan.extraLivesLeft > 0) {\n        pacMan.extraLivesLeft -= 1;\n        pacMan.game.revivePacMan();\n    }\n};\n","import { action } from 'mobx';\nimport { detectCollisions } from './detectCollisions';\nimport { Game } from './Game';\nimport { updateGhosts } from './updateGhosts';\nimport { updatePacMan } from './updatePacMan';\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\nimport { updateGameTimestamp } from './updateGameTimestamp';\n\nexport const onAnimationFrame = action('onAnimationFrame', ({ game, timestamp }: { game: Game; timestamp: number }) => {\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\n\n    if (game.gamePaused) {\n        return;\n    }\n\n    updateGameTimestamp(game);\n    updateEnergizerTimer(game);\n    updatePacMan(game);\n    // TODO: arink fix updateGhosts(game);\n    updateGhosts(game);\n    detectCollisions(game);\n});\n","import { Game } from './Game';\nimport { MilliSeconds } from './Types';\n\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\n\nexport const updateExternalTimestamp = ({ game, externalTimeStamp }: { game: Game; externalTimeStamp: number }) => {\n    if (game.externalTimeStamp === null) {\n        // The very first frame\n        // We cannot measure its duration. Therefore we have to make an assumption.\n        game.lastFrameLength = TYPICAL_FRAME_LENGTH;\n    } else {\n        // A later frame.\n        // We can calculate its duration.\n        game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\n    }\n    game.externalTimeStamp = externalTimeStamp;\n};\n","import { Game } from './Game';\n\nexport const updateGameTimestamp = (game: Game) => {\n    game.timestamp += game.lastFrameLength;\n    game.frameCount++;\n};\n","import { Game } from './Game';\n\nexport const updateEnergizerTimer = (game: Game) => {\n    game.energizerTimer.advance(game.lastFrameLength);\n};\n","import { useStore } from '../components/StoreContext';\nimport { onAnimationFrame } from './onAnimationFrame';\nimport { useAnimationLoop } from './useAnimationLoop';\n\nexport const useGameLoop = () => {\n    const store = useStore();\n\n    const animationStep = (timestamp: number) => {\n        const { game } = store;\n        onAnimationFrame({ game, timestamp });\n    };\n\n    useAnimationLoop(animationStep);\n};\n","import { useEffect, useRef } from 'react';\nimport { MilliSeconds } from './Types';\n\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\n\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\n    const requestRef = useRef(-1);\n\n    const animate = (timestamp: number) => {\n        animationStep(timestamp);\n        requestRef.current = requestAnimationFrame(animate);\n    };\n\n    useEffect(() => {\n        requestAnimationFrame(animate);\n        return () => {\n            cancelAnimationFrame(requestRef.current);\n        };\n        // eslint-disable-next-line  react-hooks/exhaustive-deps\n    }, []);\n};\n","import { Row } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React, { useEffect } from 'react';\nimport styled from 'styled-components/macro';\nimport { Board } from '../../components/Board';\nimport { ExtraLives } from './components/ExtraLives';\nimport { GameOver } from './components/GameOver';\nimport { GhostsGameView } from './components/GhostsView';\nimport { MazeView } from './components/MazeView';\nimport { PacManView } from './components/PacManView';\nimport { PillsView } from './components/PillsView';\nimport { Score } from './components/Score';\nimport { useStore } from '../../components/StoreContext';\nimport { useKeyboardActions } from './components/useKeyboardActions';\nimport { VSpace } from '../../components/Spacer';\nimport { useGameLoop } from '../../model/useGameLoop';\n\nexport const GamePage: React.FC = observer(() => {\n    const store = useStore();\n    useEffect(() => {\n        store.resetGame();\n        return () => {\n            store.game.gamePaused = true;\n        };\n        // eslint-disable-next-line  react-hooks/exhaustive-deps\n    }, []);\n\n    useGameLoop();\n    useKeyboardActions();\n\n    return (\n        <Layout data-teclastid=\"GamePage\">\n            <ScoreArea>\n                <Row justify=\"center\">\n                    <Score />\n                </Row>\n                <VSpace size=\"small\" />\n            </ScoreArea>\n\n            <EmptyArea />\n\n            <BoardArea>\n                <Board>\n                    <MazeView />\n                    <PillsView />\n                    <PacManView />\n                    <GhostsGameView />\n                    <GameOver />\n                </Board>\n                <VSpace size=\"large\" />\n                <Row justify=\"center\">\n                    <ExtraLives />\n                </Row>\n            </BoardArea>\n        </Layout>\n    );\n});\n\nconst Layout = styled.div`\n    margin-left: 16px;\n    margin-right: 16px;\n\n    display: grid;\n\n    @media (min-width: 1280px) {\n        grid-template-columns: 1fr 1fr;\n        justify-items: center;\n    }\n    @media (max-width: 1280px) {\n        grid-template-columns: 1fr;\n        justify-items: center;\n    }\n`;\n\nconst ScoreArea = styled.div``;\n\nconst EmptyArea = styled.div``;\n\nconst BoardArea = styled.div``;\n","import { useCallback, useEffect } from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\n/* eslint-disable  react-hooks/exhaustive-deps */\nexport const useKeyboardActions = (): void => {\n    const store = useStore();\n\n    const onKeyDown = useCallback((event: KeyboardEvent) => {\n        const { game } = store;\n        const pressedKey = event.key;\n        const pacMan = game.pacMan;\n        console.log(\"pressedKey\", pressedKey);\n        switch (pressedKey.toUpperCase()) {\n            case 'A':\n                pacMan.nextDirection = 'LEFT';\n                break;\n            case 'D':\n                pacMan.nextDirection = 'RIGHT';\n                break;\n            case 'W':\n                pacMan.nextDirection = 'UP';\n                break;\n            case 'S':\n                pacMan.nextDirection = 'DOWN';\n                break;\n            case ' ':\n                game.gamePaused = !game.gamePaused;\n                break;\n            default:\n                break;\n        }\n    }, []);\n\n    useEffect(() => {\n        document.addEventListener('keydown', onKeyDown);\n\n        return () => {\n            document.removeEventListener('keydown', onKeyDown);\n        };\n    }, []);\n};\n","import { Ghost } from './Ghost';\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\n\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\n    ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_GHOST_STATE = 'scatter';\n\ninterface GhostEventHandler {\n    onScatterToChase(): void;\n    onChaseToScatter(): void;\n    onDead(): void;\n}\n\ntype GhostContext = {};\n\ninterface GhostStateSchema {\n    states: {\n        chase: {};\n        scatter: {};\n        frightened: {};\n        dead: {};\n    };\n}\n\nexport type GhostEventType = 'RESET' | 'ENERGIZER_EATEN' | 'ENERGIZER_TIMED_OUT' | 'PHASE_END' | 'COLLISION_WITH_PAC_MAN' | 'REVIVED';\n\ntype GhostEvent = { type: GhostEventType };\n\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\n\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\n    id: 'ghost',\n    initial: INITIAL_GHOST_STATE,\n    on: {\n        RESET: INITIAL_GHOST_STATE\n    },\n    states: {\n        chase: {\n            on: {\n                ENERGIZER_EATEN: 'frightened',\n                PHASE_END: {\n                    target: 'scatter',\n                    actions: 'onChaseToScatter'\n                },\n                COLLISION_WITH_PAC_MAN: {\n                    target: 'scatter'\n                }\n            }\n        },\n        scatter: {\n            on: {\n                ENERGIZER_EATEN: 'frightened',\n                PHASE_END: {\n                    target: 'chase',\n                    actions: 'onScatterToChase'\n                },\n                COLLISION_WITH_PAC_MAN: {\n                    target: 'scatter'\n                }\n            }\n        },\n        frightened: {\n            on: {\n                ENERGIZER_TIMED_OUT: 'chase',\n                COLLISION_WITH_PAC_MAN: {\n                    target: 'dead',\n                    actions: 'onDead'\n                }\n            }\n        },\n        dead: {\n            on: {\n                REVIVED: 'scatter',\n                ENERGIZER_TIMED_OUT: 'scatter'\n            }\n        }\n    }\n});\n\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\n    const extended = GhostStateChart.withConfig({\n        actions: {\n            onScatterToChase: eventHandler.onScatterToChase,\n            onChaseToScatter: eventHandler.onChaseToScatter,\n            onDead: eventHandler.onDead\n        }\n    });\n    const stateChart = interpret(extended);\n    return stateChart;\n};\n","import { MilliSeconds } from './Types';\nimport { observable, computed, action } from 'mobx';\n\nexport type TimerCallback = () => void;\n\nexport class TimeoutTimer {\n    duration: MilliSeconds;\n    readonly onTimedOut: TimerCallback | null;\n\n    @observable\n    running: boolean;\n\n    @observable\n    timeSpent: MilliSeconds;\n\n    constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\n        this.duration = duration;\n        this.onTimedOut = onTimedOut;\n        this.running = false;\n        this.timeSpent = 0;\n    }\n\n    @action\n    setDuration(duration: MilliSeconds) {\n        this.duration = duration;\n    }\n\n    @action.bound\n    start() {\n        this.running = true;\n        this.timeSpent = 0;\n    }\n\n    @action\n    advance(timePassed: MilliSeconds) {\n        if (!this.running) {\n            return;\n        }\n        this.timeSpent += timePassed;\n        if (this.isTimedOut) {\n            this.onTimedOut?.();\n            this.stop();\n        }\n    }\n\n    @action\n    stop() {\n        this.running = false;\n    }\n\n    restart() {\n        this.stop();\n        this.start();\n    }\n\n    @computed\n    get timeLeft() {\n        return this.duration - this.timeSpent;\n    }\n\n    @computed\n    get isTimedOut() {\n        return this.timeSpent >= this.duration;\n    }\n}\n","import { action, computed, observable } from 'mobx';\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\nimport { ScreenCoordinates, screenFromTile, TileCoordinates, tileFromScreen } from './Coordinates';\nimport { findWayPoints } from './findWayPoints';\nimport { Game } from './Game';\nimport { GhostEventType, makeGhostStateChart, GhostState } from './GhostStateChart';\nimport { Direction, MilliSeconds } from './Types';\nimport { isTileInBox as isTileInBoxWalls, isTileCenter, isTileInBoxSpace } from './Ways';\nimport { StateValue } from 'xstate';\nimport { TimeoutTimer } from './TimeoutTimer';\nimport { getStatePhaseLength } from './updateGhostStatePhase';\n\nexport type GhostNumber = 0 | 1 | 2 | 3;\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\nexport type GhostAnimationPhase = 0 | 1;\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\nexport type FrightenedGhostTime = 0 | 1;\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\n\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 3000;\n\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\n\nexport class Ghost {\n    constructor(game: Game) {\n        this.game = game;\n\n        this.stateChart.onTransition(this.handleStateTransition);\n        this.stateChart.start();\n    }\n\n    @action.bound\n    handleStateTransition(state: GhostState) {\n        if (!state.changed) {\n            return;\n        }\n        this.stateChartState = state;\n        this.stateChanges++;\n    }\n\n    stateChart = makeGhostStateChart({\n        onScatterToChase: this.onScatterToChase,\n        onChaseToScatter: this.onChaseToScatter,\n        onDead: this.onDead\n    });\n\n    @action.bound\n    onDead() {\n        this.game.killedGhosts++;\n        this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\n        this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\n    }\n\n    @action.bound\n    onScatterToChase() {\n        changeDirectionToOpposite(this);\n    }\n\n    @action.bound\n    onChaseToScatter() {\n        changeDirectionToOpposite(this);\n    }\n\n    @observable.ref\n    stateChartState: GhostState = this.stateChart.state;\n\n    @computed\n    get state(): StateValue {\n        return this.stateChartState.value;\n    }\n\n    @observable\n    stateChanges = 0;\n\n    @computed\n    get dead() {\n        return this.stateChartState.matches('dead');\n    }\n\n    @computed\n    get alive() {\n        return !this.dead;\n    }\n\n    @computed get frightened(): boolean {\n        return this.stateChartState.matches('frightened');\n    }\n\n    name = 'ghost name';\n\n    send(event: GhostEventType) {\n        this.stateChart.send(event);\n    }\n\n    @observable\n    ghostPaused = true;\n\n    game: Game;\n\n    @observable\n    ghostNumber: GhostNumber = 0;\n\n    color = 'ghost color';\n    colorCode = '#00ffff';\n\n    @observable\n    screenCoordinates: ScreenCoordinates = {\n        x: 16,\n        y: 16\n    };\n\n    @computed\n    get atTileCenter(): boolean {\n        return isTileCenter(this.screenCoordinates);\n    }\n\n    @observable\n    speedFactor = 1;\n\n    @action\n    setTileCoordinates(tile: TileCoordinates) {\n        this.screenCoordinates = screenFromTile(tile);\n    }\n\n    @computed\n    get tileCoordinates(): TileCoordinates {\n        return tileFromScreen(this.screenCoordinates);\n    }\n\n    @computed\n    get animationPhase(): GhostAnimationPhase {\n        return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) % 2 === 0 ? 0 : 1;\n    }\n\n    @computed\n    get frightenedAboutToEnd(): boolean {\n        return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\n    }\n\n    @observable\n    deadWaitingTimeInBoxLeft: MilliSeconds = 0;\n\n    @computed\n    get frightenedGhostTime(): FrightenedGhostTime {\n        if (!this.frightenedAboutToEnd) {\n            return 0;\n        }\n        // Blink every 0.5 seconds\n        return this.game.timestamp % 1000 < 500 ? 0 : 1;\n    }\n\n    @observable\n    direction: Direction = 'LEFT';\n\n    @observable\n    targetTile: TileCoordinates = { x: 1, y: 1 };\n\n    @computed\n    get wayPoints(): TileCoordinates[] | null {\n        const ways = this.game.maze.ways;\n        return findWayPoints(this.tileCoordinates, this.targetTile, this.direction, this.canPassThroughBoxDoor, ways);\n    }\n\n    statePhaseTimer = new TimeoutTimer(3000);\n\n    @computed\n    get isInsideBoxWalls(): boolean {\n        return isTileInBoxWalls(this.tileCoordinates);\n    }\n\n    @computed\n    get isOutsideBoxSpace() {\n        return !isTileInBoxSpace(this.tileCoordinates);\n    }\n\n    @computed\n    get canPassThroughBoxDoor(): boolean {\n        if (this.alive) {\n            if (this.isInsideBoxWalls) {\n                if (this.game.timestamp > this.initialWaitingTimeInBox) {\n                    return true;\n                }\n            }\n        }\n\n        if (this.dead) {\n            if (this.isOutsideBoxSpace) {\n                return true;\n            }\n\n            // Dead && Inside box\n            if (this.deadWaitingTimeInBoxLeft <= 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @action\n    resetGhost() {\n        this.ghostPaused = false;\n        this.send('RESET');\n        this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\n        this.statePhaseTimer.restart();\n    }\n\n    initialWaitingTimeInBox = 0;\n}\n","import { TileCoordinates } from './Coordinates';\nimport { Direction } from './Types';\nimport { isEqual } from 'lodash';\nimport { chooseNextTile } from './chooseNextTile';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\n\nexport const findWayPoints = (\n    origin: TileCoordinates,\n    destination: TileCoordinates,\n    currentDirection: Direction,\n    boxDoorIsOpen: boolean,\n    waysMatrix\n): TileCoordinates[] | null => {\n    const way: TileCoordinates[] = [origin];\n    let currentTile = origin;\n    let workingDirection = currentDirection;\n    while (!isEqual(currentTile, destination)) {\n        const nextTile = chooseNextTile({\n            currentTile,\n            currentDirection: workingDirection,\n            targetTile: destination,\n            boxDoorIsOpen,\n            waysMatrix\n        });\n        // Prevent endless iteration\n        if (way.some((wayPoint) => isEqual(wayPoint, nextTile))) {\n            return way;\n        }\n        way.push(nextTile);\n        workingDirection = getDirectionFromTileToTile(currentTile, nextTile) as Direction;\n        currentTile = nextTile;\n    }\n    return way;\n};\n","import { Game } from './Game';\nimport { Ghost } from './Ghost';\n\nexport const resetGhosts = (ghosts: Ghost[]) => {\n    ghosts[0].setTileCoordinates({ x: 12, y: 14 });\n    ghosts[0].direction = 'LEFT';\n    ghosts[1].setTileCoordinates({ x: 13, y: 14 });\n    ghosts[1].direction = 'RIGHT';\n    ghosts[2].setTileCoordinates({ x: 14, y: 14 });\n    ghosts[3].direction = 'LEFT';\n    ghosts[3].setTileCoordinates({ x: 15, y: 14 });\n    ghosts[3].direction = 'RIGHT';\n\n    for (const ghost of ghosts) {\n        ghost.resetGhost();\n    }\n};\n\nexport const makeGhosts = (game: Game): Ghost[] => {\n    const ghosts: Ghost[] = [new Ghost(game), new Ghost(game), new Ghost(game), new Ghost(game)];\n\n    ghosts[0].ghostNumber = 0;\n    ghosts[0].name = 'Blinky';\n    ghosts[0].color = 'red';\n    ghosts[0].colorCode = '#ff0000';\n    ghosts[0].initialWaitingTimeInBox = 1000;\n\n    ghosts[1].ghostNumber = 1;\n    ghosts[1].name = 'Pinky';\n    ghosts[1].color = 'pink';\n    ghosts[1].colorCode = '#fcb5ff';\n    ghosts[1].initialWaitingTimeInBox = 1300;\n\n    ghosts[2].ghostNumber = 2;\n    ghosts[2].name = 'Inky';\n    ghosts[2].color = 'blue';\n    ghosts[2].colorCode = '#00ffff';\n    ghosts[2].initialWaitingTimeInBox = 1600;\n\n    ghosts[3].ghostNumber = 3;\n    ghosts[3].name = 'Clyde';\n    ghosts[3].color = 'orange';\n    ghosts[3].colorCode = '#f9ba55';\n    ghosts[3].initialWaitingTimeInBox = 1900;\n\n    resetGhosts(ghosts);\n\n    return ghosts;\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_PACMAN_STATE = 'eating';\n\ninterface EventHandler {\n    onChasing(): void;\n    onDead(): void;\n}\n\ntype PacManContext = {};\n\ninterface PacManStateSchema {\n    states: {\n        eating: {};\n        chasing: {};\n        dead: {};\n    };\n}\n\nexport type PacManEventType = 'ENERGIZER_EATEN' | 'ENERGIZER_TIMED_OUT' | 'COLLISION_WITH_GHOST' | 'REVIVED';\n\ntype PacManEvent = { type: PacManEventType };\n\nexport type PacManState = State<PacManContext, PacManEvent, PacManStateSchema, any>;\n\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>({\n    id: 'pac-man',\n    initial: INITIAL_PACMAN_STATE,\n    states: {\n        eating: {\n            on: {\n                ENERGIZER_EATEN: 'chasing',\n                COLLISION_WITH_GHOST: 'dead'\n            }\n        },\n        chasing: {\n            entry: 'onChasing',\n            on: {\n                ENERGIZER_TIMED_OUT: 'eating'\n            }\n        },\n        dead: {\n            entry: 'onDead',\n            on: {\n                REVIVED: 'eating'\n            }\n        }\n    }\n});\n\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\n    const extended = PacManStateChart.withConfig({\n        actions: {\n            onChasing: eventHandler.onChasing,\n            onDead: eventHandler.onDead\n        }\n    });\n    const stateChart = interpret(extended);\n    return stateChart;\n};\n","import { observable, action, computed } from 'mobx';\n\nimport { Direction, MilliSeconds } from './Types';\nimport { tileFromScreen, screenFromTile, TileCoordinates, ScreenCoordinates, assertValidTileCoordinates } from './Coordinates';\nimport { makePacManStateChart, PacManEventType, INITIAL_PACMAN_STATE, PacManState } from './PacManStateChart';\nimport { Game } from './Game';\nimport { StateValue } from 'xstate';\n\nexport class PacMan {\n    constructor(game: Game) {\n        this.game = game;\n        this.stateChart.onTransition(this.handleTransition);\n        this.stateChart.start();\n    }\n\n    @action.bound\n    handleTransition(state: PacManState) {\n        if (!state.changed) {\n            return;\n        }\n        this.stateChartState = state;\n    }\n\n    game: Game;\n\n    stateChart = makePacManStateChart({\n        onChasing: this.onChasing,\n        onDead: this.onDead\n    });\n\n    @observable.ref\n    stateChartState: PacManState = this.stateChart.state;\n\n    @action.bound\n    onChasing() {\n        this.game.energizerTimer.start();\n    }\n\n    @action.bound\n    onDead() {\n        this.diedAtTimestamp = this.game.timestamp;\n    }\n\n    @computed\n    get dead(): boolean {\n        return this.stateChartState.matches('dead');\n    }\n\n    @computed\n    get state(): StateValue {\n        return this.stateChartState.value;\n    }\n\n    send(event: PacManEventType) {\n        this.stateChart.send(event);\n    }\n\n    @computed\n    get alive() {\n        return !this.dead;\n    }\n\n    @observable\n    screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\n\n    @action\n    setTileCoordinates(tile: TileCoordinates) {\n        assertValidTileCoordinates(tile);\n        this.screenCoordinates = screenFromTile(tile);\n    }\n\n    @computed\n    get tileCoordinates(): TileCoordinates {\n        return tileFromScreen(this.screenCoordinates);\n    }\n\n    @observable\n    diedAtTimestamp: MilliSeconds = -1;\n\n    @computed\n    get timeSinceDeath(): MilliSeconds {\n        if (this.alive) {\n            return 0;\n        }\n        return this.game.timestamp - this.diedAtTimestamp;\n    }\n\n    @observable\n    extraLivesLeft = 2;\n\n    @observable\n    direction: Direction = 'RIGHT';\n    nextDirection: Direction = 'RIGHT';\n}\n\nexport const resetPacMan = (pacMan: PacMan) => {\n    pacMan.diedAtTimestamp = -1;\n    pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\n    pacMan.setTileCoordinates({ x: 14, y: 23 });\n    pacMan.nextDirection = 'LEFT';\n    pacMan.direction = 'LEFT';\n};\n","import { action, computed, observable } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { makeGhosts, resetGhosts } from './makeGhosts';\nimport { Maze } from './Maze';\nimport { PacMan, resetPacMan } from './PacMan';\nimport { MilliSeconds, PixelsPerFrame } from './Types';\nimport { Store } from './Store';\nimport { TimeoutTimer } from './TimeoutTimer';\n\nexport const DEFAULT_SPEED = 2;\n\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\n\nexport class Game {\n    constructor(store: Store) {\n        console.log('Game-IN');\n        this.store = store;\n        this.pacMan = new PacMan(this);\n        this.ghosts = makeGhosts(this);\n        this.maze = new Maze(this);\n    }\n\n    store: Store;\n\n    //** The timestamp we got from requestAnimationFrame().\n    @observable\n    externalTimeStamp: MilliSeconds | null = null;\n\n    @observable\n    timestamp: MilliSeconds = 0;\n\n    @observable\n    lastFrameLength: MilliSeconds = 17;\n\n    @observable\n    frameCount = 0;\n\n    @observable\n    gamePaused = false;\n\n    speed: PixelsPerFrame = DEFAULT_SPEED;\n\n    ghosts: Ghost[];\n\n    pacMan: PacMan;\n\n    @observable\n    score = 0;\n\n    @observable\n    killedGhosts = 0;\n\n    maze: Maze;\n\n    @action.bound\n    revivePacMan() {\n        this.pacMan.send('REVIVED');\n        this.timestamp = 0;\n        resetPacMan(this.pacMan);\n        resetGhosts(this.ghosts);\n    }\n\n    @computed\n    get gameOver(): boolean {\n        const pacMan = this.pacMan;\n        return pacMan.dead && pacMan.extraLivesLeft === 0;\n    }\n\n    energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\n        this.handleEnergizerTimedOut();\n    });\n\n    @action\n    handleEnergizerTimedOut() {\n        this.pacMan.send('ENERGIZER_TIMED_OUT');\n        for (const ghost of this.ghosts) {\n            ghost.send('ENERGIZER_TIMED_OUT');\n        }\n    }\n\n    readyGameForPlay() {\n        //this.maze.buildGame();\n        resetPacMan(this.pacMan);\n    }\n}\n","import { observable } from 'mobx';\nimport { Store } from './Store';\nimport { GhostViewOptions } from './GhostViewOptions';\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\nimport { GameViewOptions } from './GameViewOptions';\n\nexport class DebugState {\n    constructor(store: Store) {\n        this.store = store;\n    }\n\n    store: Store;\n\n    @observable\n    gameViewOptions: GameViewOptions = {\n        hitBox: false\n    };\n\n    @observable\n    ghostViewOptions: GhostViewOptions = {\n        target: false,\n        wayPoints: false\n    };\n\n    @observable\n    pacManViewOptions: PacManViewOptions = {\n        somePlaceholder: false\n    };\n}\n","import { observable, action } from 'mobx';\nimport { Game } from './Game';\nimport { DebugState } from './DebugState';\n\nexport class Store {\n    @observable\n    game: Game = new Game(this);\n\n    debugState = new DebugState(this);\n\n    @action.bound\n    resetGame() {\n        console.log(\"resetGame\");\n        this.game.readyGameForPlay();\n    }\n}\n","import { FC, ComponentType } from 'react';\n//import 'antd/dist/antd.compact.css';\n\nimport './GlobalStyles.css';\nimport { GamePage } from './pages/GamePage/GamePage';\nimport { Store } from './model/Store';\nimport { StoreProvider } from './components/StoreContext';\n\nconst Pacman: FC<{ store?: Store; Router?: ComponentType }> = ({ store = new Store() }) => {\n    return (\n        <StoreProvider value={store}>\n            <div>\n                <GamePage />\n            </div>\n        </StoreProvider>\n    );\n};\n\nexport default Pacman;\n","// material-ui\nimport { Button } from '@mui/material';\nimport { Link } from 'react-router-dom';\n\n// project imports\nimport MainCard from 'ui-component/cards/MainCard';\nimport Pacman from './Pacman';\n\n// ==============================|| SAMPLE PAGE ||============================== //\n\nconst RemixGame = () => {\n    return (\n    <Button variant=\"outlined\" component={Link} to=\"/pacman/remix\">\n        Remix this game\n    </Button>);\n}\n\nconst PacmanGame = () => (\n    <MainCard title=\"Pacman Game\" secondary={<RemixGame/>}>\n        <Pacman />\n    </MainCard>\n);\n\nexport default PacmanGame;\n"],"sourceRoot":""}