{"version":3,"sources":["games/pacman-game/components/Board.tsx","games/pacman-game/util/assert.ts","games/pacman-game/components/StoreContext.ts","games/pacman-game/model/MazeData.ts","games/pacman-game/model/Coordinates.ts","games/pacman-game/components/Sprite.tsx","games/pacman-game/components/Box.tsx","games/pacman-game/model/collisionDetection.ts","games/pacman-game/model/eatEnergizer.ts","games/pacman-game/model/detectCollisions.ts","games/pacman-game/model/pacManDyingPhase.ts","games/pacman-game/pages/GamePage/components/PacManView.tsx","games/pacman-game/pages/GamePage/components/ExtraLives.tsx","games/pacman-game/pages/GamePage/components/Message.tsx","games/pacman-game/pages/GamePage/components/GameOver.tsx","games/pacman-game/pages/WayFindingPage/WayPoint.tsx","games/pacman-game/model/getDirectionFromTileToTile.ts","games/pacman-game/pages/WayFindingPage/WayPoints.tsx","games/pacman-game/pages/GamePage/components/Target.tsx","games/pacman-game/pages/GamePage/components/GhostsView.tsx","games/pacman-game/pages/GamePage/components/MazeView.tsx","games/pacman-game/pages/GamePage/components/PillsView.tsx","games/pacman-game/pages/GamePage/components/Score.tsx","games/pacman-game/components/Spacer.tsx","games/pacman-game/model/Types.ts","games/pacman-game/model/Vector.ts","games/pacman-game/model/Ways.ts","games/pacman-game/model/getTileDistance.ts","games/pacman-game/model/chooseNewTargetTile.ts","games/pacman-game/model/chooseNextTile.ts","games/pacman-game/model/updateGhostStatePhase.ts","games/pacman-game/model/updateGhosts.ts","games/pacman-game/model/movePacManBy.ts","games/pacman-game/model/updatePacMan.ts","games/pacman-game/model/onAnimationFrame.ts","games/pacman-game/model/updateExternalTimeStamp.ts","games/pacman-game/model/updateGameTimestamp.ts","games/pacman-game/model/updateEnergizerTimer.ts","games/pacman-game/model/useGameLoop.ts","games/pacman-game/model/useAnimationLoop.ts","games/pacman-game/pages/GamePage/GamePage.tsx","games/pacman-game/pages/GamePage/components/useKeyboardActions.ts","games/pacman-game/model/changeDirectionToOpposite.ts","games/pacman-game/model/GhostStateChart.ts","games/pacman-game/model/TimeoutTimer.ts","games/pacman-game/model/Ghost.ts","games/pacman-game/model/findWayPoints.ts","games/pacman-game/model/makeGhosts.ts","games/pacman-game/model/Maze.ts","games/pacman-game/model/PacManStateChart.ts","games/pacman-game/model/PacMan.ts","games/pacman-game/model/Game.ts","games/pacman-game/model/DebugState.ts","games/pacman-game/model/Store.ts","games/pacman-game/Pacman.tsx","games/pacman-game/index.js"],"names":["Board","className","children","classNames","assert","condition","msg","Error","StoreContext","createContext","StoreProvider","Provider","useStore","store","useContext","useGame","game","BASIC_PILL_ID","getLayer","layerName","layer","MapData","layers","find","name","pillsLayer","waysLayer","MAZE_WIDTH_IN_TILES","width","MAZE_HEIGHT_IN_TILES","height","getTileMatrix","data","tileMatrix","Array","dataIndex","ty","tx","tileId","waysMatrix","SCALE_FACTOR","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER","SCREEN_TILE_CENTER_VECTOR","x","y","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_HEIGHT_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","Math","floor","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","scale","Sprite","spriteName","style","position","left","top","transform","transformOrigin","Box","rect","color","backgroundColor","zIndex","collide","rect1","rect2","eatEnergizer","action","score","killedGhosts","pacMan","send","ghosts","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","maze","pills","eatPill","console","error","ghostCollidesWithPacMan","ghost","detectCollisions","dead","pillTile","tileCoordinates","pillHitBox","pacManHitBox","screenCoordinates","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","TotalPacManDyingAnimationLength","from","keys","PacManDyingPhaseLength","PacManView","observer","alive","direction","gameViewOptions","debugState","pacManAnimationPhase","getPacManAnimationPhase","dyingPhase","timeSinceDeath","PacManDyingPhaseCount","getPacManDyingPhase","hitBox","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","dyingPacManAnimationPhase","step","round","timestamp","PacManSprite","DyingPacManSprite","PacManHitBox","ExtraLives","Layout","times","extraLivesLeft","n","styled","div","Message","text","MessageStyled","span","GameOver","gameOver","POINTS","DirectionToAngle","DOWN","LEFT","UP","RIGHT","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","TUNNEL_X_RIGHT","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","WayPoints","wayPoints","map","wayPoint","index","getDirection","length","indexToUse","fromTile","toTile","Target","version","d","GhostsGameView","ghostViewOptions","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","ghostNumber","target","GhostView","colorCode","targetTile","animationPhase","state","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","MazeView","BasicPillView","EnergizerView","PillView","PillsView","memo","_","displayName","Score","SIZE_MAPPING","small","medium","large","mappedSize","size","VSpace","Directions","assertValidDirection","includes","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","directionToVector","distance","moveFromTile","steps","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","getTileDistance","neighbourTile","dx","abs","dy","sqrt","pow","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","isInsideBoxWalls","chooseForGhost2InChaseState","to","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","filter","max","newDirection","random","chooseInDeadMode","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","JSON","stringify","candidates","possibleNextTile","distanceToTarget","push","bestCandidate","minBy","neighbourTileInCurrentDirection","isWayFreeForGhostAt","updateGhostStatePhaseTime","statePhaseTimer","advance","lastFrameLength","updateGhostStatePhase","atTileCenter","isTimedOut","setDuration","getStatePhaseLength","restart","updateGhost","ghostPaused","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","deadWaitingTimeInBoxLeft","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","canPassThroughBoxDoor","getGhostMovementVector","moveGhostBy","speed","movePacManBy","updateLivingPacMan","nextDirection","movePacMan","delta","directionAsVector","updateDeadPacMan","revivePacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","gamePaused","frameCount","updateGameTimestamp","energizerTimer","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","useRef","animate","current","requestAnimationFrame","useEffect","cancelAnimationFrame","useAnimationLoop","GamePage","resetGame","onKeyDown","useCallback","event","pressedKey","key","document","addEventListener","removeEventListener","useKeyboardActions","data-teclastid","ScoreArea","justify","EmptyArea","BoardArea","changeDirectionToOpposite","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","actions","COLLISION_WITH_PAC_MAN","scatter","frightened","ENERGIZER_TIMED_OUT","REVIVED","TimeoutTimer","bound","duration","onTimedOut","this","running","timeSpent","timePassed","stop","start","observable","computed","KILL_GHOST_SCORE","Ghost","ref","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","stateChanges","value","matches","timeLeft","frightenedAboutToEnd","origin","destination","way","workingDirection","some","findWayPoints","isOutsideBoxSpace","resetGhosts","setTileCoordinates","resetGhost","Maze","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","handleTransition","diedAtTimestamp","resetPacMan","Game","handleEnergizerTimedOut","makeGhosts","DebugState","somePlaceholder","Store","readyGameForPlay","Pacman","PacmanGame","Grid","container","item","xs","Card","CardHeader","title","Typography","variant","Divider","CardContent"],"mappings":"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","file":"static/js/5.adb00a1d.chunk.js","sourcesContent":["import React from 'react';\nimport './Board.css';\nimport classNames from 'classnames';\n\nexport const Board: React.FC<{ className?: string }> = ({\n  className,\n  children,\n}) => <div className={classNames('Board', className)}>{children}</div>;\n","export function assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(`Assertion error ${msg ?? ''}`);\n  }\n}\n","import { createContext, useContext } from 'react';\nimport { Game } from '../model/Game';\nimport { assert } from '../util/assert';\nimport { Store } from '../model/Store';\n\nexport const StoreContext = createContext<Store | null>(null);\n\nexport const StoreProvider = StoreContext.Provider;\n\nexport const useStore = (): Store => {\n  const store = useContext(StoreContext);\n  assert(store, 'Store not provided - use <StoreProvider>');\n  return store;\n};\n\nexport const useGame = (): Game => {\n  const store = useStore();\n  return store.game;\n};\n","import MapData from '../mapData/pacman6.json';\n\nexport type TileId = number;\n\nexport const EMPTY_TILE_ID: TileId = 0;\nexport const BASIC_PILL_ID: TileId = 3533;\nexport const ENERGIZER_ID: TileId = 3589;\n\nexport const WAY_FREE_ID: TileId = 5240;\nexport const BOX_DOOR_ID: TileId = 5241;\n\nexport type TileMatrix = TileId[][];\n\ninterface Layer {\n  data: number[];\n  width: number;\n  height: number;\n}\n\nconst getLayer = (layerName: string): Layer => {\n  const layer = MapData.layers.find(layer => layer.name === layerName);\n  if (!layer) {\n    throw new Error(`${layerName} layer not found`);\n  }\n  return layer;\n};\n\nconst pillsLayer: Layer = getLayer('Pills');\nconst waysLayer: Layer = getLayer('Ways');\n\nexport const MAZE_WIDTH_IN_TILES = pillsLayer.width;\nexport const MAZE_HEIGHT_IN_TILES = pillsLayer.height;\n\nexport const getTileMatrix = (data: TileId[]): TileMatrix => {\n  const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n  let dataIndex = 0;\n  for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n    tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n    for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n      const tileId = data[dataIndex];\n      tileMatrix[ty][tx] = tileId;\n      dataIndex++;\n    }\n  }\n  return tileMatrix;\n};\n\nexport const getPillsMatrix = (): TileMatrix => getTileMatrix(pillsLayer.data);\n\nexport const waysMatrix: TileMatrix = getTileMatrix(waysLayer.data);\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './MazeData';\nimport { assert } from '../util/assert';\nimport { Vector } from './Vector';\n\nexport type Coordinate = number;\n\nexport type TileCoordinate = Coordinate;\nexport type ScreenCoordinate = Coordinate;\n\nexport interface TileCoordinates {\n  x: TileCoordinate;\n  y: TileCoordinate;\n}\n\nexport interface ScreenCoordinates {\n  x: ScreenCoordinate;\n  y: ScreenCoordinate;\n}\n\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\n\nexport interface TileRectangle {\n  tile1: TileCoordinates;\n  tile2: TileCoordinates;\n}\n\nexport const SCALE_FACTOR = 2.5;\nexport const SPRITE_TILE_SIZE = 8;\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\n\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\n  x: SCREEN_TILE_CENTER,\n  y: SCREEN_TILE_CENTER,\n};\n\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES =\n  MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES =\n  MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\n\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\n  x: MAZE_WIDTH_IN_TILES,\n  y: MAZE_HEIGHT_IN_TILES,\n};\n\nexport const isTxValid = (tx: TileCoordinate) =>\n  tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\nexport const isTyValid = (ty: TileCoordinate) =>\n  ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\nexport const isValidTileCoordinates = (tile: TileCoordinates) =>\n  isTxValid(tile.x) && isTyValid(tile.y);\n\nexport const assertValidTx = (tx: TileCoordinate) => {\n  assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\n};\n\nexport const assertValidTy = (ty: TileCoordinate) => {\n  assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\n};\n\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\n  assertValidTx(tile.x);\n  assertValidTy(tile.y);\n};\n\nexport const screenFromTileCoordinate = (\n  tileCoordinate: TileCoordinate\n): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\n\nexport const tileFromScreenCoordinate = (\n  screenCoordinate: ScreenCoordinate\n): TileCoordinate => Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\n\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\n  x: screenFromTileCoordinate(tile.x),\n  y: screenFromTileCoordinate(tile.y),\n});\n\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\n  x: tileFromScreenCoordinate(screen.x),\n  y: tileFromScreenCoordinate(screen.y),\n});\n\nexport const getPointDifferenceAsVector = (\n  from: Coordinates,\n  to: Coordinates\n): Vector => ({\n  x: to.x - from.x,\n  y: to.y - from.y,\n});\n\nexport const addCoordinatesAndVector = (\n  coordinates: Coordinates,\n  vector: Vector\n): ScreenCoordinates => ({\n  x: coordinates.x + vector.x,\n  y: coordinates.y + vector.y,\n});\n\nexport const rectangleContainsTile = (\n  tileRectangle: TileRectangle,\n  tile: TileCoordinates\n): boolean =>\n  tile.x >= tileRectangle.tile1.x &&\n  tile.x <= tileRectangle.tile2.x &&\n  tile.y >= tileRectangle.tile1.y &&\n  tile.y <= tileRectangle.tile2.y;\n\nexport const wrapTileToBounds = (\n  tile: TileCoordinates,\n  bounds: TileCoordinates\n): TileCoordinates => {\n  const wrappedX = (tile.x + bounds.x) % bounds.x;\n  const wrappedY = (tile.y + bounds.y) % bounds.y;\n  return { x: wrappedX, y: wrappedY };\n};\n","import React, { FC, CSSProperties } from 'react';\nimport classNames from 'classnames';\nimport { SCALE_FACTOR } from '../model/Coordinates';\nimport './Sprite.css';\n\nconst scale = `scale(${SCALE_FACTOR})`;\n\nexport const Sprite: FC<{\n  name: string;\n  x: number;\n  y: number;\n  className?: string | null;\n  style?: CSSProperties;\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\n  return (\n    <div\n      className={classNames('Sprite', 'Sprite-' + spriteName, className)}\n      style={{\n        ...style,\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        transform: scale,\n        transformOrigin: 'top left',\n      }}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { Rectangle } from '../model/Rectangle';\n\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({\n  rect,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: rect.x,\n      top: rect.y,\n      width: rect.width,\n      height: rect.height,\n      backgroundColor: color,\n      zIndex: 1000,\n    }}\n  />\n);\n","import { Rectangle } from './Rectangle';\n\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\n  return (\n    rect1.x < rect2.x + rect2.width &&\n    rect1.x + rect1.width > rect2.x &&\n    rect1.y < rect2.y + rect2.height &&\n    rect1.y + rect1.height > rect2.y\n  );\n};\n","import { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const ENERGIZER_POINTS = 30;\n\nexport const eatEnergizer = action((game: Game) => {\n  game.score += ENERGIZER_POINTS;\n  game.killedGhosts = 0;\n  game.pacMan.send('ENERGIZER_EATEN');\n  for (const ghost of game.ghosts) {\n    ghost.send('ENERGIZER_EATEN');\n  }\n});\n","import { collide } from './collisionDetection';\nimport {\n  SCALE_FACTOR,\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n} from './Coordinates';\nimport { eatEnergizer } from './eatEnergizer';\nimport { Game } from './Game';\nimport { Ghost } from './Ghost';\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './MazeData';\nimport { Rectangle } from './Rectangle';\n\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\n\nexport const getPillHitBox = (\n  tile: TileCoordinates,\n  pill: TileId\n): Rectangle => {\n  const screen = screenFromTile(tile);\n  return {\n    x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\n    y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\n    width: PILL_BOX_HIT_BOX_WIDTH,\n    height: PILL_BOX_HIT_BOX_HEIGHT,\n  };\n};\n\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\n\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\n    y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\n    width: PAC_MAN_HIT_BOX_WIDTH,\n    height: PAC_MAN_HIT_BOX_HEIGHT,\n  };\n};\n\nconst GHOST_HIT_BOX_WIDTH = 10;\nconst GHOST_HIT_BOX_HEIGHT = 10;\n\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\n    y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\n    width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\n    height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR,\n  };\n};\n\nconst detectPacManEatingPill = (game: Game) => {\n  const pillTile = game.pacMan.tileCoordinates;\n  const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\n  if (pill === EMPTY_TILE_ID) {\n    return;\n  }\n\n  const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n  if (collide(pacManHitBox, pillHitBox)) {\n    eatPillLayerObject(pillTile, game);\n  }\n};\n\nexport const BASIC_PILL_POINTS = 10;\n\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\n  const tileId = game.maze.pills[tile.y][tile.x];\n  switch (tileId) {\n    case BASIC_PILL_ID:\n      eatPill(tile, game);\n      break;\n    case ENERGIZER_ID:\n      eatEnergizer(game);\n      break;\n    default:\n      console.error('Unknown pill layer tile id', tileId);\n      break;\n  }\n\n  game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\n};\n\nconst eatPill = (tile: TileCoordinates, game: Game) => {\n  game.score += BASIC_PILL_POINTS;\n};\n\nconst detectGhostCollisions = (game: Game) => {\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n\n  for (const ghost of game.ghosts) {\n    if (ghost.dead) {\n      continue;\n    }\n\n    const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\n    if (collide(pacManHitBox, ghostHitBox)) {\n      ghostCollidesWithPacMan(ghost);\n    }\n  }\n};\n\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\n  const game = ghost.game;\n  game.pacMan.send('COLLISION_WITH_GHOST');\n  ghost.send('COLLISION_WITH_PAC_MAN');\n};\n\nexport const detectCollisions = (game: Game) => {\n  if (game.pacMan.dead) {\n    return;\n  }\n\n  detectPacManEatingPill(game);\n  detectGhostCollisions(game);\n};\n","import { MilliSeconds } from './Types';\nimport { PacMan } from './PacMan';\n\nexport type PacManDyingPhase = number;\nexport const PacManDyingPhaseCount = 13;\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(\n  Array(PacManDyingPhaseCount).keys()\n);\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\nexport const TotalPacManDyingAnimationLength: MilliSeconds =\n  PacManDyingPhaseLength * PacManDyingPhaseCount;\n\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\n  let dyingPhase: number = Math.floor(\n    pacMan.timeSinceDeath / PacManDyingPhaseLength\n  );\n  if (dyingPhase >= PacManDyingPhaseCount) {\n    dyingPhase = PacManDyingPhaseCount - 1;\n  }\n  return dyingPhase as PacManDyingPhase;\n};\n","import React, { FC, CSSProperties } from 'react';\nimport { Sprite } from '../../../components/Sprite';\nimport { Direction } from '../../../model/Types';\nimport { observer } from 'mobx-react-lite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { Box } from '../../../components/Box';\nimport { PacMan } from '../../../model/PacMan';\nimport { getPacManHitBox } from '../../../model/detectCollisions';\nimport {\n  PacManDyingPhase,\n  getPacManDyingPhase,\n} from '../../../model/pacManDyingPhase';\n\nexport type PacManAnimationPhase = 0 | 1 | 2;\n\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\n\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\n\nexport const PacManView: FC = observer(() => {\n  const store = useStore();\n  const game = useGame();\n  const pacMan = game.pacMan;\n  const { dead, alive, screenCoordinates, direction } = pacMan;\n  const { gameViewOptions } = store.debugState;\n  const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\n  const dyingPhase = getPacManDyingPhase(pacMan);\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <PacManHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n        />\n      )}\n      {alive && (\n        <PacManSprite\n          direction={direction}\n          pacManAnimationPhase={pacManAnimationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n      {dead && (\n        <DyingPacManSprite\n          dyingPacManAnimationPhase={dyingPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n    </>\n  );\n});\n\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\n  const step = Math.round(pacMan.game.timestamp / 200) % 4;\n  const phase = step === 3 ? 1 : step;\n  return phase as PacManAnimationPhase;\n};\n\nexport const PacManSprite: FC<{\n  direction: Direction;\n  pacManAnimationPhase: PacManAnimationPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-pacman\"\n    name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const DyingPacManSprite: FC<{\n  dyingPacManAnimationPhase: PacManDyingPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-dying-pacman\"\n    name={`dying-pacman-phase-${dyingPacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\n  const rect = getPacManHitBox({ x, y });\n  return <Box rect={rect} color=\"green\" />;\n};\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport classNames from 'classnames';\nimport styled from 'styled-components/macro';\nimport { PacManSprite } from './PacManView';\nimport { times } from 'lodash';\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\n\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\n  const game = useGame();\n  return (\n    <Layout className={classNames('ExtraLives', className)}>\n      <span>\n        {times(game.pacMan.extraLivesLeft, n => (\n          <PacManSprite\n            key={n}\n            direction=\"LEFT\"\n            pacManAnimationPhase={1}\n            x={n * 20 * SCALE_FACTOR}\n            y={0}\n          />\n        ))}\n      </span>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  display: inline-flex;\n  position: relative;\n  width: calc(1 * 40px * var(--SCALE_FACTOR));\n  height: calc(16px * var(--SCALE_FACTOR));\n`;\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\n\nexport const Message = observer<{ className?: string; text: string }>(\n  ({ className, text }) => {\n    return <MessageStyled className={className}>{text}</MessageStyled>;\n  }\n);\n\nconst MessageStyled = styled.span`\n  font-family: Joystix;\n  font-size: 24px;\n  color: yellow;\n  position: absolute;\n  left: 170px;\n  top: 332px;\n  width: 220px;\n  text-align: center;\n`;\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport './GameOver.css';\nimport { useGame } from '../../../components/StoreContext';\nimport { Message } from './Message';\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\n\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\n\nexport const GameOver: FC<{ className?: string }> = observer(\n  ({ className }) => {\n    const game = useGame();\n    const { pacMan } = game;\n    const gameOverMessageVisible =\n      game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\n\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\n  }\n);\n","import React from 'react';\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Direction } from '../../model/Types';\n\nconst x1 = 30;\nconst y1 = 30;\nconst x2 = 70;\nconst y2 = 70;\nconst x3 = 50;\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\n\nconst DirectionToAngle = {\n  DOWN: 0,\n  LEFT: 90,\n  UP: 180,\n  RIGHT: 270,\n};\n\nexport const WayPoint: React.FC<{\n  screenCoordinates: ScreenCoordinates;\n  color: string;\n  direction: Direction;\n}> = ({ screenCoordinates, color, direction }) => {\n  const angle = DirectionToAngle[direction];\n  return (\n    <SvgStyled\n      viewBox=\"0 0 100 100\"\n      height=\"6\"\n      width=\"6\"\n      style={{\n        left: `${screenCoordinates.x + 1}px`,\n        top: `${screenCoordinates.y}px`,\n      }}\n    >\n      <g transform={`rotate(${angle} 50 50)`}>\n        <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\n      </g>\n    </SvgStyled>\n  );\n};\n\nconst SvgStyled = styled.svg`\n  position: absolute;\n  display: block;\n  width: ${SCREEN_TILE_SIZE}px;\n  height: ${SCREEN_TILE_SIZE}px;\n  pointer-events: none;\n`;\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\nimport { isEqual } from 'lodash';\nimport { assert } from '../util/assert';\nimport { Direction } from './Types';\nimport { MAZE_WIDTH_IN_TILES } from './MazeData';\n\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\n\nexport const getDirectionFromTileToTile = (\n  tileFrom: TileCoordinates,\n  tileTo: TileCoordinates\n): Direction => {\n  assert(tileFrom, 'tileFrom');\n  assert(tileTo, 'tileTo');\n\n  if (isEqual(tileFrom, tileTo)) {\n    throw new Error('Same tile');\n  }\n\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\n    return 'RIGHT';\n  }\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\n    return 'LEFT';\n  }\n  if (tileFrom.x < tileTo.x) {\n    return 'RIGHT';\n  }\n  if (tileFrom.x > tileTo.x) {\n    return 'LEFT';\n  }\n  if (tileFrom.y < tileTo.y) {\n    return 'DOWN';\n  }\n  if (tileFrom.y > tileTo.y) {\n    return 'UP';\n  }\n  throw new Error('Same tiles');\n};\n","/* eslint-disable react/no-unescaped-entities */\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\nimport { WayPoint } from './WayPoint';\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\nimport { Direction } from '../../model/Types';\nimport { assert } from '../../util/assert';\n\nexport const WayPoints = observer<{\n  wayPoints: TileCoordinates[];\n  color: string;\n}>(({ wayPoints, color }) => (\n  <>\n    {wayPoints.map((wayPoint, index) => {\n      const screenCoordinates = screenFromTile(wayPoint);\n      const direction = getDirection(wayPoints, index);\n      return (\n        <WayPoint\n          key={index}\n          screenCoordinates={screenCoordinates}\n          color={color}\n          direction={direction}\n        />\n      );\n    })}\n  </>\n));\n\nconst getDirection = (\n  wayPoints: TileCoordinates[],\n  index: number\n): Direction => {\n  if (wayPoints.length <= 1) {\n    return 'DOWN';\n  }\n  const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\n  const fromTile = wayPoints[indexToUse];\n  const toTile = wayPoints[indexToUse + 1];\n  assert(toTile, `${indexToUse} ${wayPoints.length}`);\n  const direction = getDirectionFromTileToTile(fromTile, toTile);\n  return direction;\n};\n","import React, { FC } from 'react';\nimport {\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  screenFromTileCoordinate,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\n\nconst SIZE = SCREEN_TILE_SIZE * 2;\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\n\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({\n  tile,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: screenFromTileCoordinate(tile.x) + OFFSET,\n      top: screenFromTileCoordinate(tile.y) + OFFSET,\n      width: SIZE,\n      height: SIZE,\n    }}\n  >\n    <svg version=\"1.1\" viewBox=\"0 0 22 22\">\n      <path\n        style={{ fill: color }}\n        transform={`rotate(45 11 11) translate(-550.29-608.65)`}\n        d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\n      />\n    </svg>\n  </div>\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { getGhostHitBox } from '../../../model/detectCollisions';\nimport {\n  Ghost,\n  GhostAnimationPhase,\n  FrightenedGhostTime,\n} from '../../../model/Ghost';\nimport { Direction } from '../../../model/Types';\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { Target } from './Target';\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\nimport { GameViewOptions } from '../../../model/GameViewOptions';\n\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\n\nexport const GhostsGameView = observer(() => {\n  const store = useStore();\n  const { ghostViewOptions, gameViewOptions } = store.debugState;\n\n  return (\n    <GhostsView\n      ghostViewOptions={ghostViewOptions}\n      gameViewOptions={gameViewOptions}\n    />\n  );\n});\n\nexport const GhostsView: FC<{\n  ghostViewOptions?: GhostViewOptions;\n  gameViewOptions?: GameViewOptions;\n}> = observer(\n  ({\n    ghostViewOptions = DefaultGhostViewOptions,\n    gameViewOptions = DefaultGameViewOptions,\n  }) => {\n    const store = useGame();\n\n    return (\n      <>\n        {store.ghosts.map(ghost => (\n          <GhostCompositeView\n            key={ghost.ghostNumber}\n            ghost={ghost}\n            ghostViewOptions={ghostViewOptions}\n            gameViewOptions={gameViewOptions}\n          />\n        ))}\n      </>\n    );\n  }\n);\n\nconst DefaultGhostViewOptions: GhostViewOptions = {\n  target: false,\n  wayPoints: false,\n};\n\nconst DefaultGameViewOptions: GameViewOptions = {\n  hitBox: false,\n};\n\nexport const GhostCompositeView: FC<{\n  ghost: Ghost;\n  ghostViewOptions: GhostViewOptions;\n  gameViewOptions: GameViewOptions;\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\n  const { screenCoordinates } = ghost;\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <GhostHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n          color=\"green\"\n        />\n      )}\n      <GhostView ghost={ghost} />\n      {ghostViewOptions.wayPoints && (\n        <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />\n      )}\n      {ghostViewOptions.target && (\n        <Target tile={ghost.targetTile} color={ghost.colorCode} />\n      )}\n    </>\n  );\n});\n\nexport const GhostView: FC<{\n  ghost: Ghost;\n}> = observer(({ ghost }) => {\n  const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\n  // TODO\n  switch (ghost.state) {\n    case 'frightened':\n      return (\n        <FrightenedGhostSprite\n          frightenedGhostTime={ghost.frightenedGhostTime}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    case 'dead':\n      return (\n        <DeadGhostSprite\n          direction={direction}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    default:\n      return (\n        <GhostSprite\n          direction={direction}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n          ghostNumber={ghostNumber}\n        />\n      );\n  }\n});\n\ntype GhostSpriteProps = {\n  direction: Direction;\n  ghostAnimationPhase: GhostAnimationPhase;\n  x: number;\n  y: number;\n  ghostNumber: number;\n  style?: { [key: string]: any };\n};\n\nexport const GhostSprite: FC<GhostSpriteProps> = ({\n  direction,\n  ghostAnimationPhase: phase,\n  x,\n  y,\n  ghostNumber,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype DeadGhostSpriteProps = {\n  direction: Direction;\n  x: number;\n  y: number;\n  style?: { [key: string]: any };\n};\n\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({\n  direction,\n  x,\n  y,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`dead-ghost-direction-${direction}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype FrightenedGhostSpriteProps = {\n  x: number;\n  y: number;\n  ghostAnimationPhase: GhostAnimationPhase;\n  frightenedGhostTime: FrightenedGhostTime;\n  style?: { [key: string]: any };\n};\n\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({\n  x,\n  y,\n  ghostAnimationPhase,\n  frightenedGhostTime,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({\n  x,\n  y,\n  color,\n}) => {\n  const rect = getGhostHitBox({ x, y });\n  return <Box rect={rect} color={color} />;\n};\n\n","import React, { FC } from 'react';\nimport { Sprite } from '../../../components/Sprite';\n\nexport const MazeView: FC = () => (\n  <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC, memo } from 'react';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport {\n  addCoordinatesAndVector,\n  ScreenCoordinates,\n  screenFromTile,\n  SCREEN_TILE_CENTER_VECTOR,\n  TileCoordinates,\n} from '../../../model/Coordinates';\nimport { getPillHitBox } from '../../../model/detectCollisions';\nimport {\n  BASIC_PILL_ID,\n  ENERGIZER_ID,\n  MAZE_HEIGHT_IN_TILES,\n  MAZE_WIDTH_IN_TILES,\n  EMPTY_TILE_ID,\n} from '../../../model/MazeData';\nimport { useGame } from '../../../components/StoreContext';\n\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\n);\n\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\n);\n\nexport const BasicPillHitBox: FC = () => {\n  const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\n  return <Box rect={rect} color=\"blue\" />;\n};\n\nconst PillView = observer<{ tile: TileCoordinates }>(\n  ({ tile }: { tile: TileCoordinates }) => {\n    const game = useGame();\n    const { x, y } = tile;\n    const tileId = game.maze.pills[y][x];\n    if (tileId === BASIC_PILL_ID) {\n      return (\n        <BasicPillView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    if (tileId === ENERGIZER_ID) {\n      return (\n        <EnergizerView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    return null;\n  }\n);\n\n// Performance tricks used here:\n// Make each PillView an observer, so that we don't have to rerender PillsView.\n// Make PillsView a React.memo to prevent any rerenders.\n// Also: Create PillView only for those coordinates where there is a pill on first render.\nexport const PillsView: FC = memo(() => {\n  const game = useGame();\n\n  return (\n    <>\n      {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\n        Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\n          const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\n          return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\n        })\n      )}\n    </>\n  );\n});\n\nPillsView.displayName = 'displayName';\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport './Score.css';\nimport classNames from 'classnames';\n\nexport const Score = observer<{ className?: string }>(({ className }) => {\n  const store = useGame();\n  return (\n    <div className={classNames('Score', className)}>\n      <span>Score</span>\n      <span>{store.score}</span>\n    </div>\n  );\n});\n","import styled from 'styled-components/macro';\nconst DEFAULT_SIZE = '8px';\n\nconst SIZE_MAPPING: { [key: string]: string } = {\n  small: '8px',\n  medium: '16px',\n  large: '24px',\n};\n\ntype Size = 'small' | 'middle' | 'large' | string;\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\n\nexport const HSpace = styled.div<{ size?: Size }>`\n  width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n\nexport const VSpace = styled.div<{ size?: Size }>`\n  height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n","import { assert } from '../util/assert';\n\nexport type PixelsPerFrame = number;\n\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\n\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\n\nexport type MilliSeconds = number;\n\nexport const assertValidDirection = (direction: Direction) => {\n  assert(Directions.includes(direction), `Bad direction ${direction}`);\n};\n","export interface Vector {\n  x: number;\n  y: number;\n}\n\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector =>\n  multiplyVector(-1, vector);\n\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\n  x: factor * vector.x,\n  y: factor * vector.y,\n});\n\nexport const divideVector = (vector: Vector, divisor: number): Vector =>\n  multiplyVector(1 / divisor, vector);\n","import { Direction, assertValidDirection } from './Types';\nimport {\n  assertValidTileCoordinates,\n  ScreenCoordinates,\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  rectangleContainsTile,\n  TileRectangle,\n  wrapTileToBounds,\n  MAZE_DIMENSIONS_IN_TILES,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { waysMatrix, WAY_FREE_ID, BOX_DOOR_ID } from './MazeData';\nimport { Vector, multiplyVector } from './Vector';\n\nconst BOX_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 10, y: 12 },\n  tile2: { x: 17, y: 16 },\n};\n\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 12, y: 14 },\n  tile2: { x: 15, y: 14 },\n};\n\nexport const isWayFreeAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\n};\n\nexport const isBoxDoorAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\n};\n\nexport const isTileInBox = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_TILE_COORDINATES, tile);\n\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\n\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\n  return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\n};\n\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n\nexport const directionToVector = (direction: Direction, distance = 1): Vector =>\n  multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\n\nexport const moveFromTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  steps = 1\n) => {\n  const step = DIRECTION_TO_VECTOR[direction];\n  const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\n  return newTile;\n};\n\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\n  RIGHT: 'LEFT',\n  LEFT: 'RIGHT',\n  UP: 'DOWN',\n  DOWN: 'UP',\n};\n\nexport const isOppositeDirection = (\n  direction1: Direction,\n  direction2: Direction\n) => {\n  return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\n};\n\nexport const isWayFreeInDirection = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): boolean => {\n  const nextTile = getNextTile(tile, direction, stepSize);\n  return isWayFreeAt(nextTile);\n};\n\nexport const getNextTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): TileCoordinates => {\n  assertValidDirection(direction);\n  const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\n  const scaledVector = multiplyVector(stepSize, vector);\n  const movedTile = addCoordinatesAndVector(tile, scaledVector);\n  const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\n  return nextTile;\n};\n\nconst DIRECTION_TO_TILE_VECTOR = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n","import { TileCoordinates } from './Coordinates';\n\nexport const getTileDistance = (\n  neighbourTile: TileCoordinates,\n  targetTile: TileCoordinates\n) => {\n  const dx = Math.abs(neighbourTile.x - targetTile.x);\n  const dy = Math.abs(neighbourTile.y - targetTile.y);\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import {\n  TileCoordinates,\n  getPointDifferenceAsVector,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { Ghost } from './Ghost';\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { Directions, Direction } from './Types';\nimport { rotateVectorBy180Degrees } from './Vector';\nimport { assert } from '../util/assert';\n\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\n  x: 13,\n  y: 11,\n};\n\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\n  x: 14,\n  y: 14,\n};\n\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\n\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\n  switch (ghost.state) {\n    case 'scatter':\n      return chooseInScatterMode(ghost);\n    case 'chase':\n      return choseInChaseMode(ghost);\n    case 'frightened':\n      return chooseInFrightenedMode(ghost);\n    case 'dead':\n      return chooseInDeadMode(ghost);\n    default:\n      throw new Error(`Bad state ${ghost.state}`);\n  }\n};\n\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return SCATTER_TILE_FOR_GHOST_0;\n    case 1:\n      return { x: 1, y: 1 };\n    case 2:\n      return { x: 26, y: 29 };\n    case 3:\n      return { x: 1, y: 29 };\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  return pacMan.tileCoordinates;\n};\n\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const fourTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    4\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(fourTilesAhead, 'LEFT', 4)\n    : fourTilesAhead;\n};\n\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\n  const intermediateTile = chooseGhost2IntermediateTile(ghost);\n  const blinky = ghost.game.ghosts[0];\n  const vectorToBlinky = getPointDifferenceAsVector(\n    intermediateTile,\n    blinky.tileCoordinates\n  );\n  const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\n  const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\n\n  return newTile;\n};\n\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const twoTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    2\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(twoTilesAhead, 'LEFT', 2)\n    : twoTilesAhead;\n};\n\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const distance = getTileDistance(\n    ghost.tileCoordinates,\n    pacMan.tileCoordinates\n  );\n\n  return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\n};\n\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return chooseForGhost0InChaseState(ghost);\n    case 1:\n      return chooseForGhost1InChaseState(ghost);\n    case 2:\n      return chooseForGhost2InChaseState(ghost);\n    case 3:\n      return chooseForGhost3InChaseState(ghost);\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst getRandomInt = (max: number) =>\n  Math.floor(Math.random() * Math.floor(max));\n\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\n  // Choose a random neighbour tile that is not backward and not into a wall.\n\n  return chooseSomeRandomMovement(ghost);\n};\n\n/**\n * Choose a random neighbour tile that is not backward and not into a wall.\n */\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\n  const candidateDirections: Direction[] = Directions.filter(\n    direction =>\n      direction !== ghost.direction &&\n      isWayFreeInDirection(ghost.tileCoordinates, direction)\n  );\n  assert(candidateDirections.length > 0);\n  const newDirection =\n    candidateDirections[getRandomInt(candidateDirections.length)];\n  assert(newDirection);\n  const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\n\n  return randomNeighourTile;\n};\n\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\n  // if (ghost.deadWaitingTimeInBoxLeft < 0) {\n  //   return chooseSomeRandomMovement(ghost);\n  // }\n  return TILE_FOR_RETURNING_TO_BOX;\n};\n","import { minBy } from 'lodash';\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\nimport { Direction, Directions } from './Types';\nimport {\n  getNextTile,\n  isOppositeDirection,\n  isWayFreeAt,\n  isBoxDoorAt,\n} from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { toJS } from 'mobx';\nimport { assert } from '../util/assert';\n\ninterface CandidateTile {\n  tile: TileCoordinates;\n  distanceToTarget: number;\n}\n\nexport const chooseNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates => {\n  assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\n  const bestNextTile = chooseBestNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  if (bestNextTile) {\n    assert(isValidTileCoordinates(bestNextTile));\n    return bestNextTile;\n  }\n\n  const anyNextTile = chooseAnyNextTile({\n    currentTile,\n    currentDirection,\n    boxDoorIsOpen,\n  });\n  if (anyNextTile) {\n    assert(isValidTileCoordinates(anyNextTile));\n    return anyNextTile;\n  }\n\n  console.error('currentTile', currentTile);\n  console.error('currentDirection', currentDirection);\n  console.error('boxDoorIsOpen', boxDoorIsOpen);\n  console.error('targetTile', toJS(targetTile));\n\n  throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\n};\n\nconst chooseBestNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  const candidates = [] as CandidateTile[];\n  for (const direction of Directions) {\n    // Prevent the ghost from going backwards\n    if (isOppositeDirection(direction, currentDirection)) {\n      continue;\n    }\n    const neighbourTile = getNextTile(currentTile, direction);\n\n    if (!possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      continue;\n    }\n\n    const distanceToTarget = getTileDistance(neighbourTile, targetTile);\n    candidates.push({ tile: neighbourTile, distanceToTarget });\n  }\n\n  const bestCandidate = minBy(candidates, 'distanceToTarget');\n  if (bestCandidate) {\n    return bestCandidate.tile;\n  } else {\n    return null;\n  }\n};\n\nconst chooseAnyNextTile = ({\n  currentTile,\n  currentDirection,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  // Prioritize the current direction\n  const neighbourTileInCurrentDirection = getNextTile(\n    currentTile,\n    currentDirection\n  );\n\n  if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen)) {\n    return neighbourTileInCurrentDirection;\n  }\n\n  // Choose any possible next tile\n  for (const direction of Directions) {\n    const neighbourTile = getNextTile(currentTile, direction);\n    if (possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      return neighbourTile;\n    }\n  }\n\n  return null;\n};\n\nconst possibleNextTile = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean => {\n  return (\n    isValidTileCoordinates(tileCoordinates) &&\n    isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen)\n  );\n};\n\nconst isWayFreeForGhostAt = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean =>\n  isWayFreeAt(tileCoordinates) ||\n  (boxDoorIsOpen && isBoxDoorAt(tileCoordinates));\n","import { action } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { MilliSeconds } from './Types';\nimport { StateValue } from 'xstate';\n\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\n\nexport const updateGhostStatePhaseTime = action(\n  'updateGhostStatePhaseTime',\n  (ghost: Ghost) => {\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\n  }\n);\n\nexport const updateGhostStatePhase = action(\n  'updateGhostStatePhase',\n  (ghost: Ghost) => {\n    if (!ghost.atTileCenter) {\n      return;\n    }\n\n    if (ghost.statePhaseTimer.isTimedOut) {\n      ghost.send('PHASE_END');\n      ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\n      ghost.statePhaseTimer.restart();\n    }\n  }\n);\n\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\n  switch (state) {\n    case 'chase':\n      return CHASE_PHASE_LENGTH;\n    case 'scatter':\n      return SCATTER_PHASE_LENGTH;\n    default:\n      // Never ends\n      return 9999999999;\n  }\n};\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\nimport { chooseNextTile } from './chooseNextTile';\nimport {\n  TileCoordinates,\n  MAZE_WIDTH_IN_SCREEN_COORDINATES,\n  MAZE_HEIGHT_IN_SCREEN_COORDINATES,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\nimport { Ghost } from './Ghost';\nimport { Direction } from './Types';\nimport { directionToVector } from './Ways';\nimport {\n  updateGhostStatePhaseTime,\n  updateGhostStatePhase,\n} from './updateGhostStatePhase';\nimport { Vector } from './Vector';\nimport { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const updateGhosts = (game: Game) => {\n  for (const ghost of game.ghosts) {\n    updateGhost({ ghost });\n  }\n};\n\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\n  if (ghost.ghostPaused) {\n    return;\n  }\n\n  updateGhostStatePhaseTime(ghost);\n  updateDeadWaitingTimeInBoxLeft(ghost);\n\n  updateGhostStatePhase(ghost);\n\n  routeAndMoveGhost(ghost);\n};\n\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\n  if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\n    ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\n  }\n};\n\nexport const routeAndMoveGhost = (ghost: Ghost) => {\n  if (ghost.game.pacMan.dead) {\n    return;\n  }\n\n  if (ghost.atTileCenter) {\n    reRouteGhost(ghost);\n  }\n\n  moveGhost(ghost);\n};\n\nconst reRouteGhost = (ghost: Ghost) => {\n  ghost.targetTile = chooseNewTargetTile(ghost);\n  updateDirection(ghost);\n  updateSpeed(ghost);\n};\n\nconst updateDirection = (ghost: Ghost) => {\n  const newDirection = getNewDirection(ghost);\n  ghost.direction = newDirection;\n};\n\nconst updateSpeed = (ghost: Ghost) => {\n  const newSpeedFactor = getNewSpeedFactor(ghost);\n  ghost.speedFactor = newSpeedFactor;\n};\n\nexport const getNewDirection = (ghost: Ghost): Direction => {\n  const currentTile = ghost.tileCoordinates;\n  const currentDirection = ghost.direction;\n  const targetTile = ghost.targetTile;\n  const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\n\n  const nextTile: TileCoordinates = chooseNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  return getDirectionFromTileToTile(currentTile, nextTile);\n};\n\nconst moveGhost = (ghost: Ghost) => {\n  const vector: Vector = getGhostMovementVector(ghost);\n  moveGhostBy(ghost, vector);\n};\n\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\n  ghost.screenCoordinates.x =\n    (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  ghost.screenCoordinates.y =\n    (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) %\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES;\n\n  assertValidTileCoordinates(ghost.tileCoordinates);\n});\n\nconst isInTunnel = (tile: TileCoordinates) =>\n  tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\n\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\n  const speed = ghost.game.speed * ghost.speedFactor;\n  const velocity = directionToVector(ghost.direction, speed);\n  return velocity;\n};\n\nexport const SPEED_FACTOR_HIGH = 2;\nexport const SPEED_FACTOR_NORMAL = 1;\nexport const SPEED_FACTOR_SLOW = 0.5;\n\nconst getNewSpeedFactor = (ghost: Ghost): number => {\n  if (ghost.dead) {\n    return SPEED_FACTOR_HIGH;\n  }\n  if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\n    return SPEED_FACTOR_SLOW;\n  }\n  return SPEED_FACTOR_NORMAL;\n};\n","import { action } from 'mobx';\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { Vector } from './Vector';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\n  pacMan.screenCoordinates.x =\n    (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  pacMan.screenCoordinates.y += vector.y;\n});\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\nimport { Game } from './Game';\nimport { movePacManBy } from './movePacManBy';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport {\n  directionToVector as directionAsVector,\n  isTileCenter,\n  isWayFreeInDirection,\n} from './Ways';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const updatePacMan = (game: Game): void => {\n  const pacMan = game.pacMan;\n  if (pacMan.alive) {\n    updateLivingPacMan(pacMan);\n  } else {\n    updateDeadPacMan(pacMan);\n  }\n};\n\nconst updateLivingPacMan = (pacMan: PacMan) => {\n  if (isTileCenter(pacMan.screenCoordinates)) {\n    const tile = tileFromScreen(pacMan.screenCoordinates);\n\n    // Change direction if necessary\n    if (\n      pacMan.direction !== pacMan.nextDirection &&\n      isWayFreeInDirection(tile, pacMan.nextDirection)\n    ) {\n      pacMan.direction = pacMan.nextDirection;\n    }\n\n    // Move\n    if (isWayFreeInDirection(tile, pacMan.direction)) {\n      movePacMan(pacMan);\n    }\n  } else {\n    movePacMan(pacMan);\n  }\n};\n\nconst movePacMan = (pacMan: PacMan): void => {\n  const speed = pacMan.game.speed;\n  const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\n  movePacManBy(pacMan, delta);\n};\n\nconst updateDeadPacMan = (pacMan: PacMan) => {\n  if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\n    revivePacMan(pacMan);\n  }\n  return;\n};\n\nconst revivePacMan = (pacMan: PacMan) => {\n  if (pacMan.extraLivesLeft > 0) {\n    pacMan.extraLivesLeft -= 1;\n    pacMan.game.revivePacMan();\n  }\n};\n","import { action } from 'mobx';\nimport { detectCollisions } from './detectCollisions';\nimport { Game } from './Game';\nimport { updateGhosts } from './updateGhosts';\nimport { updatePacMan } from './updatePacMan';\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\nimport { updateGameTimestamp } from './updateGameTimestamp';\n\nexport const onAnimationFrame = action(\n  'onAnimationFrame',\n  ({ game, timestamp }: { game: Game; timestamp: number }) => {\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\n\n    if (game.gamePaused) {\n      return;\n    }\n\n    updateGameTimestamp(game);\n    updateEnergizerTimer(game);\n    updatePacMan(game);\n    updateGhosts(game);\n    detectCollisions(game);\n  }\n);\n","import { Game } from './Game';\nimport { MilliSeconds } from './Types';\n\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\n\nexport const updateExternalTimestamp = ({\n  game,\n  externalTimeStamp,\n}: {\n  game: Game;\n  externalTimeStamp: number;\n}) => {\n  if (game.externalTimeStamp === null) {\n    // The very first frame\n    // We cannot measure its duration. Therefore we have to make an assumption.\n    game.lastFrameLength = TYPICAL_FRAME_LENGTH;\n  } else {\n    // A later frame.\n    // We can calculate its duration.\n    game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\n  }\n  game.externalTimeStamp = externalTimeStamp;\n};\n","import { Game } from './Game';\n\nexport const updateGameTimestamp = (game: Game) => {\n  game.timestamp += game.lastFrameLength;\n  game.frameCount++;\n};\n","import { Game } from './Game';\n\nexport const updateEnergizerTimer = (game: Game) => {\n  game.energizerTimer.advance(game.lastFrameLength);\n};\n","import { useStore } from '../components/StoreContext';\nimport { onAnimationFrame } from './onAnimationFrame';\nimport { useAnimationLoop } from './useAnimationLoop';\n\nexport const useGameLoop = () => {\n  const store = useStore();\n\n  const animationStep = (timestamp: number) => {\n    const { game } = store;\n    onAnimationFrame({ game, timestamp });\n  };\n\n  useAnimationLoop(animationStep);\n};\n","import { useEffect, useRef } from 'react';\nimport { MilliSeconds } from './Types';\n\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\n\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\n  const requestRef = useRef(-1);\n\n  const animate = (timestamp: number) => {\n    animationStep(timestamp);\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n};\n","import { Row } from 'antd';\nimport { observer } from 'mobx-react-lite';\nimport React, { useEffect } from 'react';\nimport styled from 'styled-components/macro';\nimport { Board } from '../../components/Board';\nimport { ExtraLives } from './components/ExtraLives';\nimport { GameOver } from './components/GameOver';\nimport { GhostsGameView } from './components/GhostsView';\nimport { MazeView } from './components/MazeView';\nimport { PacManView } from './components/PacManView';\nimport { PillsView } from './components/PillsView';\nimport { Score } from './components/Score';\nimport { useStore } from '../../components/StoreContext';\nimport { useKeyboardActions } from './components/useKeyboardActions';\nimport { VSpace } from '../../components/Spacer';\nimport { useGameLoop } from '../../model/useGameLoop';\n\nexport const GamePage: React.FC = observer(() => {\n  const store = useStore();\n  useEffect(() => {\n    store.resetGame();\n    return () => {\n      store.game.gamePaused = true;\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n\n  useGameLoop();\n  useKeyboardActions();\n\n  return (\n    <Layout data-teclastid=\"GamePage\">\n      <ScoreArea>\n        <Row justify=\"center\">\n          <Score />\n        </Row>\n        <VSpace size=\"small\" />\n      </ScoreArea>\n\n      <EmptyArea />\n\n      <BoardArea >\n        <Board >\n          <MazeView />\n          <PillsView />\n          <PacManView />\n          <GhostsGameView />\n          <GameOver />\n        </Board>\n        <VSpace size=\"large\" />\n        <Row justify=\"center\">\n          <ExtraLives />\n        </Row>\n      </BoardArea>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  margin-left: 16px;\n  margin-right: 16px;\n\n  display: grid;\n\n  @media (min-width: 1280px) {\n    grid-template-columns: 1fr 1fr;\n    justify-items: center;\n  }\n  @media (max-width: 1280px) {\n    grid-template-columns: 1fr;\n    justify-items: center;\n  }\n`;\n\nconst ScoreArea = styled.div``;\n\nconst EmptyArea = styled.div``;\n\nconst BoardArea = styled.div``;\n","import { useCallback, useEffect } from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\n/* eslint-disable  react-hooks/exhaustive-deps */\nexport const useKeyboardActions = (): void => {\n  const store = useStore();\n\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\n    const { game } = store;\n    const pressedKey = event.key;\n    const pacMan = game.pacMan;\n    switch (pressedKey) {\n      case 'ArrowLeft':\n        pacMan.nextDirection = 'LEFT';\n        break;\n      case 'ArrowRight':\n        pacMan.nextDirection = 'RIGHT';\n        break;\n      case 'ArrowUp':\n        pacMan.nextDirection = 'UP';\n        break;\n      case 'ArrowDown':\n        pacMan.nextDirection = 'DOWN';\n        break;\n      case ' ':\n        game.gamePaused = !game.gamePaused;\n        break;\n      default:\n        break;\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, []);\n};\n","import { Ghost } from './Ghost';\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\n\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\n  ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_GHOST_STATE = 'scatter';\n\ninterface GhostEventHandler {\n  onScatterToChase(): void;\n  onChaseToScatter(): void;\n  onDead(): void;\n}\n\ntype GhostContext = {};\n\ninterface GhostStateSchema {\n  states: {\n    chase: {};\n    scatter: {};\n    frightened: {};\n    dead: {};\n  };\n}\n\nexport type GhostEventType =\n  | 'RESET'\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'PHASE_END'\n  | 'COLLISION_WITH_PAC_MAN'\n  | 'REVIVED';\n\ntype GhostEvent = { type: GhostEventType };\n\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\n\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\n  id: 'ghost',\n  initial: INITIAL_GHOST_STATE,\n  on: {\n    RESET: INITIAL_GHOST_STATE,\n  },\n  states: {\n    chase: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'scatter',\n          actions: 'onChaseToScatter',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    scatter: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'chase',\n          actions: 'onScatterToChase',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    frightened: {\n      on: {\n        ENERGIZER_TIMED_OUT: 'chase',\n        COLLISION_WITH_PAC_MAN: {\n          target: 'dead',\n          actions: 'onDead',\n        },\n      },\n    },\n    dead: {\n      on: {\n        REVIVED: 'scatter',\n        ENERGIZER_TIMED_OUT: 'scatter',\n      },\n    },\n  },\n});\n\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\n  const extended = GhostStateChart.withConfig({\n    actions: {\n      onScatterToChase: eventHandler.onScatterToChase,\n      onChaseToScatter: eventHandler.onChaseToScatter,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { MilliSeconds } from './Types';\nimport { observable, computed, action } from 'mobx';\n\nexport type TimerCallback = () => void;\n\nexport class TimeoutTimer {\n  duration: MilliSeconds;\n  readonly onTimedOut: TimerCallback | null;\n\n  @observable\n  running: boolean;\n\n  @observable\n  timeSpent: MilliSeconds;\n\n  constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\n    this.duration = duration;\n    this.onTimedOut = onTimedOut;\n    this.running = false;\n    this.timeSpent = 0;\n  }\n\n  @action\n  setDuration(duration: MilliSeconds) {\n    this.duration = duration;\n  }\n\n  @action.bound\n  start() {\n    this.running = true;\n    this.timeSpent = 0;\n  }\n\n  @action\n  advance(timePassed: MilliSeconds) {\n    if (!this.running) {\n      return;\n    }\n    this.timeSpent += timePassed;\n    if (this.isTimedOut) {\n      this.onTimedOut?.();\n      this.stop();\n    }\n  }\n\n  @action\n  stop() {\n    this.running = false;\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  @computed\n  get timeLeft() {\n    return this.duration - this.timeSpent;\n  }\n\n  @computed\n  get isTimedOut() {\n    return this.timeSpent >= this.duration;\n  }\n}\n","import { action, computed, observable } from 'mobx';\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\nimport {\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n  tileFromScreen,\n} from './Coordinates';\nimport { findWayPoints } from './findWayPoints';\nimport { Game } from './Game';\nimport {\n  GhostEventType,\n  makeGhostStateChart,\n  GhostState,\n} from './GhostStateChart';\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  isTileInBox as isTileInBoxWalls,\n  isTileCenter,\n  isTileInBoxSpace,\n} from './Ways';\nimport { StateValue } from 'xstate';\nimport { TimeoutTimer } from './TimeoutTimer';\nimport { getStatePhaseLength } from './updateGhostStatePhase';\n\nexport type GhostNumber = 0 | 1 | 2 | 3;\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\nexport type GhostAnimationPhase = 0 | 1;\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\nexport type FrightenedGhostTime = 0 | 1;\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\n\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 3000;\n\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\n\nexport class Ghost {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleStateTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleStateTransition(state: GhostState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n    this.stateChanges++;\n  }\n\n  stateChart = makeGhostStateChart({\n    onScatterToChase: this.onScatterToChase,\n    onChaseToScatter: this.onChaseToScatter,\n    onDead: this.onDead,\n  });\n\n  @action.bound\n  onDead() {\n    this.game.killedGhosts++;\n    this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\n    this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\n  }\n\n  @action.bound\n  onScatterToChase() {\n    changeDirectionToOpposite(this);\n  }\n\n  @action.bound\n  onChaseToScatter() {\n    changeDirectionToOpposite(this);\n  }\n\n  @observable.ref\n  stateChartState: GhostState = this.stateChart.state;\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  @observable\n  stateChanges = 0;\n\n  @computed\n  get dead() {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @computed get frightened(): boolean {\n    return this.stateChartState.matches('frightened');\n  }\n\n  name = 'ghost name';\n\n  send(event: GhostEventType) {\n    this.stateChart.send(event);\n  }\n\n  @observable\n  ghostPaused = true;\n\n  game: Game;\n\n  @observable\n  ghostNumber: GhostNumber = 0;\n\n  color = 'ghost color';\n  colorCode = '#00ffff';\n\n  @observable\n  screenCoordinates: ScreenCoordinates = {\n    x: 16,\n    y: 16,\n  };\n\n  @computed\n  get atTileCenter(): boolean {\n    return isTileCenter(this.screenCoordinates);\n  }\n\n  @observable\n  speedFactor = 1;\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @computed\n  get animationPhase(): GhostAnimationPhase {\n    return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) %\n      2 ===\n      0\n      ? 0\n      : 1;\n  }\n\n  @computed\n  get frightenedAboutToEnd(): boolean {\n    return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\n  }\n\n  @observable\n  deadWaitingTimeInBoxLeft: MilliSeconds = 0;\n\n  @computed\n  get frightenedGhostTime(): FrightenedGhostTime {\n    if (!this.frightenedAboutToEnd) {\n      return 0;\n    }\n    // Blink every 0.5 seconds\n    return this.game.timestamp % 1000 < 500 ? 0 : 1;\n  }\n\n  @observable\n  direction: Direction = 'LEFT';\n\n  @observable\n  targetTile: TileCoordinates = { x: 1, y: 1 };\n\n  @computed\n  get wayPoints(): TileCoordinates[] | null {\n    return findWayPoints(\n      this.tileCoordinates,\n      this.targetTile,\n      this.direction,\n      this.canPassThroughBoxDoor\n    );\n  }\n\n  statePhaseTimer = new TimeoutTimer(3000);\n\n  @computed\n  get isInsideBoxWalls(): boolean {\n    return isTileInBoxWalls(this.tileCoordinates);\n  }\n\n  @computed\n  get isOutsideBoxSpace() {\n    return !isTileInBoxSpace(this.tileCoordinates);\n  }\n\n  @computed\n  get canPassThroughBoxDoor(): boolean {\n    if (this.alive) {\n      if (this.isInsideBoxWalls) {\n        if (this.game.timestamp > this.initialWaitingTimeInBox) {\n          return true;\n        }\n      }\n    }\n\n    if (this.dead) {\n      if (this.isOutsideBoxSpace) {\n        return true;\n      }\n\n      // Dead && Inside box\n      if (this.deadWaitingTimeInBoxLeft <= 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  @action\n  resetGhost() {\n    this.ghostPaused = false;\n    this.send('RESET');\n    this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\n    this.statePhaseTimer.restart();\n  }\n\n  initialWaitingTimeInBox = 0;\n}\n","import { TileCoordinates } from './Coordinates';\nimport { Direction } from './Types';\nimport { isEqual } from 'lodash';\nimport { chooseNextTile } from './chooseNextTile';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\n\nexport const findWayPoints = (\n  origin: TileCoordinates,\n  destination: TileCoordinates,\n  currentDirection: Direction,\n  boxDoorIsOpen: boolean\n): TileCoordinates[] | null => {\n  const way: TileCoordinates[] = [origin];\n  let currentTile = origin;\n  let workingDirection = currentDirection;\n  while (!isEqual(currentTile, destination)) {\n    const nextTile = chooseNextTile({\n      currentTile,\n      currentDirection: workingDirection,\n      targetTile: destination,\n      boxDoorIsOpen,\n    });\n    // Prevent endless iteration\n    if (way.some(wayPoint => isEqual(wayPoint, nextTile))) {\n      return way;\n    }\n    way.push(nextTile);\n    workingDirection = getDirectionFromTileToTile(\n      currentTile,\n      nextTile\n    ) as Direction;\n    currentTile = nextTile;\n  }\n  return way;\n};\n","import { Game } from './Game';\nimport { Ghost } from './Ghost';\n\nexport const resetGhosts = (ghosts: Ghost[]) => {\n  ghosts[0].setTileCoordinates({ x: 12, y: 14 });\n  ghosts[0].direction = 'LEFT';\n  ghosts[1].setTileCoordinates({ x: 13, y: 14 });\n  ghosts[1].direction = 'RIGHT';\n  ghosts[2].setTileCoordinates({ x: 14, y: 14 });\n  ghosts[3].direction = 'LEFT';\n  ghosts[3].setTileCoordinates({ x: 15, y: 14 });\n  ghosts[3].direction = 'RIGHT';\n\n  for (const ghost of ghosts) {\n    ghost.resetGhost();\n  }\n};\n\nexport const makeGhosts = (game: Game): Ghost[] => {\n  const ghosts: Ghost[] = [\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n  ];\n\n  ghosts[0].ghostNumber = 0;\n  ghosts[0].name = 'Blinky';\n  ghosts[0].color = 'red';\n  ghosts[0].colorCode = '#ff0000';\n  ghosts[0].initialWaitingTimeInBox = 1000;\n\n  ghosts[1].ghostNumber = 1;\n  ghosts[1].name = 'Pinky';\n  ghosts[1].color = 'pink';\n  ghosts[1].colorCode = '#fcb5ff';\n  ghosts[1].initialWaitingTimeInBox = 1300;\n\n  ghosts[2].ghostNumber = 2;\n  ghosts[2].name = 'Inky';\n  ghosts[2].color = 'blue';\n  ghosts[2].colorCode = '#00ffff';\n  ghosts[2].initialWaitingTimeInBox = 1600;\n\n  ghosts[3].ghostNumber = 3;\n  ghosts[3].name = 'Clyde';\n  ghosts[3].color = 'orange';\n  ghosts[3].colorCode = '#f9ba55';\n  ghosts[3].initialWaitingTimeInBox = 1900;\n\n  resetGhosts(ghosts);\n\n  return ghosts;\n};\n","import { observable } from 'mobx';\nimport { getPillsMatrix, TileId } from './MazeData';\n\nexport class Maze {\n  @observable\n  pills: TileId[][] = getPillsMatrix();\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_PACMAN_STATE = 'eating';\n\ninterface EventHandler {\n  onChasing(): void;\n  onDead(): void;\n}\n\ntype PacManContext = {};\n\ninterface PacManStateSchema {\n  states: {\n    eating: {};\n    chasing: {};\n    dead: {};\n  };\n}\n\nexport type PacManEventType =\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'COLLISION_WITH_GHOST'\n  | 'REVIVED';\n\ntype PacManEvent = { type: PacManEventType };\n\nexport type PacManState = State<\n  PacManContext,\n  PacManEvent,\n  PacManStateSchema,\n  any\n>;\n\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>(\n  {\n    id: 'pac-man',\n    initial: INITIAL_PACMAN_STATE,\n    states: {\n      eating: {\n        on: {\n          ENERGIZER_EATEN: 'chasing',\n          COLLISION_WITH_GHOST: 'dead',\n        },\n      },\n      chasing: {\n        entry: 'onChasing',\n        on: {\n          ENERGIZER_TIMED_OUT: 'eating',\n        },\n      },\n      dead: {\n        entry: 'onDead',\n        on: {\n          REVIVED: 'eating',\n        },\n      },\n    },\n  }\n);\n\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\n  const extended = PacManStateChart.withConfig({\n    actions: {\n      onChasing: eventHandler.onChasing,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { observable, action, computed } from 'mobx';\n\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  tileFromScreen,\n  screenFromTile,\n  TileCoordinates,\n  ScreenCoordinates,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport {\n  makePacManStateChart,\n  PacManEventType,\n  INITIAL_PACMAN_STATE,\n  PacManState,\n} from './PacManStateChart';\nimport { Game } from './Game';\nimport { StateValue } from 'xstate';\n\nexport class PacMan {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleTransition(state: PacManState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n  }\n\n  game: Game;\n\n  stateChart = makePacManStateChart({\n    onChasing: this.onChasing,\n    onDead: this.onDead,\n  });\n\n  @observable.ref\n  stateChartState: PacManState = this.stateChart.state;\n\n  @action.bound\n  onChasing() {\n    this.game.energizerTimer.start();\n  }\n\n  @action.bound\n  onDead() {\n    this.diedAtTimestamp = this.game.timestamp;\n  }\n\n  @computed\n  get dead(): boolean {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  send(event: PacManEventType) {\n    this.stateChart.send(event);\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @observable\n  screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    assertValidTileCoordinates(tile);\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @observable\n  diedAtTimestamp: MilliSeconds = -1;\n\n  @computed\n  get timeSinceDeath(): MilliSeconds {\n    if (this.alive) {\n      return 0;\n    }\n    return this.game.timestamp - this.diedAtTimestamp;\n  }\n\n  @observable\n  extraLivesLeft = 2;\n\n  @observable\n  direction: Direction = 'RIGHT';\n  nextDirection: Direction = 'RIGHT';\n}\n\nexport const resetPacMan = (pacMan: PacMan) => {\n  pacMan.diedAtTimestamp = -1;\n  pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\n  pacMan.setTileCoordinates({ x: 14, y: 23 });\n  pacMan.nextDirection = 'LEFT';\n  pacMan.direction = 'LEFT';\n};\n","import { action, computed, observable } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { makeGhosts, resetGhosts } from './makeGhosts';\nimport { Maze } from './Maze';\nimport { PacMan, resetPacMan } from './PacMan';\nimport { MilliSeconds, PixelsPerFrame } from './Types';\nimport { Store } from './Store';\nimport { TimeoutTimer } from './TimeoutTimer';\n\nexport const DEFAULT_SPEED = 2;\n\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\n\nexport class Game {\n  constructor(store: Store) {\n    this.store = store;\n    this.pacMan = new PacMan(this);\n    this.ghosts = makeGhosts(this);\n  }\n\n  store: Store;\n\n  //** The timestamp we got from requestAnimationFrame().\n  @observable\n  externalTimeStamp: MilliSeconds | null = null;\n\n  @observable\n  timestamp: MilliSeconds = 0;\n\n  @observable\n  lastFrameLength: MilliSeconds = 17;\n\n  @observable\n  frameCount = 0;\n\n  @observable\n  gamePaused = false;\n\n  speed: PixelsPerFrame = DEFAULT_SPEED;\n\n  ghosts: Ghost[];\n\n  pacMan: PacMan;\n\n  @observable\n  score = 0;\n\n  @observable\n  killedGhosts = 0;\n\n  maze = new Maze();\n\n  @action.bound\n  revivePacMan() {\n    this.pacMan.send('REVIVED');\n    this.timestamp = 0;\n    resetPacMan(this.pacMan);\n    resetGhosts(this.ghosts);\n  }\n\n  @computed\n  get gameOver(): boolean {\n    const pacMan = this.pacMan;\n    return pacMan.dead && pacMan.extraLivesLeft === 0;\n  }\n\n  energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\n    this.handleEnergizerTimedOut();\n  });\n\n  @action\n  handleEnergizerTimedOut() {\n    this.pacMan.send('ENERGIZER_TIMED_OUT');\n    for (const ghost of this.ghosts) {\n      ghost.send('ENERGIZER_TIMED_OUT');\n    }\n  }\n\n  readyGameForPlay() {\n    resetPacMan(this.pacMan);\n  }\n}\n","import { observable } from 'mobx';\nimport { Store } from './Store';\nimport { GhostViewOptions } from './GhostViewOptions';\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\nimport { GameViewOptions } from './GameViewOptions';\n\nexport class DebugState {\n  constructor(store: Store) {\n    this.store = store;\n  }\n\n  store: Store;\n\n  @observable\n  gameViewOptions: GameViewOptions = {\n    hitBox: false,\n  };\n\n  @observable\n  ghostViewOptions: GhostViewOptions = {\n    target: false,\n    wayPoints: false,\n  };\n\n  @observable\n  pacManViewOptions: PacManViewOptions = {\n    somePlaceholder: false,\n  };\n}\n","import { observable, action } from 'mobx';\nimport { Game } from './Game';\nimport { DebugState } from './DebugState';\n\nexport class Store {\n  @observable\n  game: Game = new Game(this);\n\n  debugState = new DebugState(this);\n\n  @action.bound\n  resetGame() {\n    this.game = new Game(this);\n    this.game.readyGameForPlay();\n  }\n}\n","import  { FC, ComponentType } from 'react';\nimport 'antd/dist/antd.compact.css';\n\nimport './GlobalStyles.css';\nimport { GamePage } from './pages/GamePage/GamePage';\nimport { Store } from './model/Store';\nimport { StoreProvider } from './components/StoreContext';\n\nconst Pacman: FC<{ store?: Store; Router?: ComponentType }> = ({\n  store = new Store()\n}) => {\n  return (\n    <StoreProvider value={store}>\n        <div >\n        <GamePage />\n        </div>\n    </StoreProvider>\n  );\n};\n\nexport default Pacman;\n\n","import React from 'react';\nimport {Card, CardContent, CardHeader, Divider, Grid, Typography} from '@material-ui/core';\nimport Pacman from './Pacman';\n\nconst PacmanGame = () => {\n    return (\n        <Grid container>\n            <Grid item xs={12}>\n                <Card>\n                    <CardHeader title={<Typography variant=\"h5\">Pacman Game</Typography>} />\n                    <Divider />\n                    <CardContent>\n                        <Pacman/>\n                    </CardContent>\n                </Card>\n            </Grid>\n        </Grid>\n    );\n};\n\nexport default PacmanGame;\n"],"sourceRoot":""}